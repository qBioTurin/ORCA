#shiny.maxRequestSize=1000*1024^2
#shiny.launch.browser = .rs.invokeShinyWindowExternal

Sys.setenv("DATAVERSE_SERVER" = "dataverse.harvard.edu")
APIkey_path = system.file("Data",".APIkey", package = "ORCA")

# source(system.file("Shiny","AuxFunctions.R", package = "ORCA"))
# source("./inst/Shiny/AuxFunctions.R")

# Define server logic required to draw a histogram
server <- function(input, output, session) {
  DataAnalysisModule <- reactiveValues(wbResult = NULL,
                                       wbquantResult = NULL,
                                       endocResult = NULL,
                                       elisaResult = NULL,
                                       pcrResult = NULL,
                                       cytotoxResult = NULL)
  
  DataIntegrationModule <- reactiveValues(dataLoaded = NULL,
                                          data = NULL,
                                          wbTabs = NULL, 
                                          pcrTabs = NULL,
                                          cytotoxTabs= NULL,
                                          endocTabs=NULL,
                                          otherTabs = NULL,
                                          otherTabsMean = NULL)
  
  MapAnalysisNames =c("WB", "WB comparison", "Endocytosis", "ELISA", "RT-qPCR", "Cytotoxicity") 
  names(MapAnalysisNames) =c("wbResult", "wbquantResult", "endocResult", "elisaResult", "pcrResult", "cytotoxResult") 
  
  ### WB analysis ####
  # DECLARE REACTIVEVALUES FUNCTION HERE
  PanelData = data.frame(SampleName = character(),
                         xmin = numeric(), ymin = numeric(), 
                         xmax = numeric(), ymax = numeric())
  
  wbResult <- reactiveValues(
                             Normalizer = NULL,
                             Im = NULL,
                             Planes = NULL,
                             TruncatedPanelsValue = NULL,
                             PanelsValue = NULL,
                             Plots = NULL,
                             TruncatedPlots = NULL,
                             pl = NULL,
                             AUCdf=data.frame(SampleName = "-", Truncation = "-", AUC = "-"  ))
  
  wbResult0 <- list(   Normalizer = NULL,
                         Im = NULL,
                         Planes = NULL,
                         TruncatedPanelsValue = NULL,
                         PanelsValue = NULL,
                         Plots = NULL,
                         TruncatedPlots = NULL,
                         pl = NULL,
                         AUCdf=data.frame(SampleName = "-", Truncation = "-", AUC = "-" )
  )
  
  
  # save everytime there is a change in the results
  WBresultList <- reactive({
    reactiveValuesToList(wbResult)
  })
  observeEvent(WBresultList(), {
    DataAnalysisModule$wbResult = reactiveValuesToList(wbResult)
    DataAnalysisModule$wbResult$Flags = reactiveValuesToList(Flags)
  })
  
  Flags <- reactiveValues( ShowTif = F, 
                           LanesCut = F,
                           CutTab="V",
                           IDlane = 0)
  prev_vals <- NULL
  PanelStructures <- reactiveValues(data = PanelData )
  NumberOfPlanes <- reactiveValues(N = 0)
  PlaneSelected <- reactiveValues(First = NULL)
  
  observeEvent(input$LoadingTif,{
    output$LoadingError <- renderText({
      validate(
        need(!is.null(input$imImport) && file.exists(input$imImport$datapath) ,
             "Please select a tif file!!" )
      )
      
      mess = readfile(
        filename = input$imImport$datapath,
        type = "tif"
      )
      
      validate(
        need(!setequal(names(mess),c("message","call")) ,
             mess[["message"]] )
      )
      
      Flags$ShowTif <- TRUE
      wbResult$Im = mess
      
      updateTabsetPanel(session, "SideTabs",
                        selected = "plane")
      
      "The image has been uploaded  with success"
    })
    
    if( !is.null(wbResult$Im) )
    { ### alert!!! if it is already present! 
      showModal(modalDialog(
        title = "Important message",
        "Do you want to update the WB data already present, by resetting the previous analysis?",
        easyClose = TRUE,
        footer= tagList(actionButton("confirmUpload", "Update"),
                        modalButton("Cancel")
        )
      ))
    }
  })
  
  observeEvent(input$confirmUpload,{
    DataAnalysisModule$wbResult = wbResult0
    
    for(j in names(wbResult))
      wbResult[[j]] = wbResult0[[j]]
    
    output$AUC <- renderDT({
      wbResult$AUCdf %>% 
        dplyr::select(SampleName,Truncation, AUC)},
      selection = 'none',  
      rownames= FALSE,
      editable = list(target = "cell", 
                      disable = list(columns = 1:4)))
    
    
    output$LoadingError <- renderText({
      validate(
        need(!is.null(input$imImport) && file.exists(input$imImport$datapath) ,
             "Please select a tif file!!" )
      )
      
      mess = readfile(
        filename = input$imImport$datapath,
        type = "tif"
      )
      
      validate(
        need(!setequal(names(mess),c("message","call")) ,
             mess[["message"]] )
      )
      
      Flags$ShowTif <- TRUE
      wbResult$Im = mess
      
      updateTabsetPanel(session, "SideTabs",
                        selected = "plane")
      
      "The image has been uploaded  with success"
    })
    
    removeModal()
  })
  
  observe({
    if(Flags$ShowTif)
    {
      #output$LoadingError <- renderText({      })
      #ListIm = LoadImage(input$imImport$datapath)
      wbResult$Im -> ListIm 
      im = ListIm$RGB
      
      #output$TifPlot  <- renderPlot({ imageShow(im) })
      output$TiffBox <- renderUI({
        column(12,align="center",
        box(plotOutput("TifPlot2",
                       hover = "plot_hover",
                       brush = "plot_brush"),
            width = 12,
            height = dim(im)[1]+0.1*dim(im)[1])
        )
      })
      
      output$TifPlot2 <- renderPlot({ 
        plot(c(1,dim(im)[2]),c(1,dim(im)[1]), type='n',ann=FALSE)
        rasterImage(im,1,1,dim(im)[2],dim(im)[1])
        if (nrow(PanelStructures$data) > 0) {
          r <- PanelStructures$data
          rect(r$xmin, r$ymin, r$xmax, r$ymax, border = "red")
        }
      }, width  = dim(im)[2],height = dim(im)[1] )
      
      Flags$ShowTif = FALSE
    }
  })
  
  observeEvent(input$panelSelect_button,{
    e <- input$plot_brush
    if (!is.null(e)) {
      vals <- data.frame(xmin = round(e$xmin, 1),
                         ymin = round(e$ymin, 1),
                         xmax = round(e$xmax, 1),
                         ymax = round(e$ymax, 1))
      
      if (!identical(vals,prev_vals))  #We dont want to change anything if the values havent changed.
      {
        NumberOfPlanes$N = NumberOfPlanes$N + 1
        if(NumberOfPlanes$N > 1){
          # we set the same height in the new panel
          vals$ymax = prev_vals$ymax
          vals$ymin = prev_vals$ymin
          
          newH = vals$ymax - vals$ymin
          newW = vals$xmax - vals$xmin
          prevH = prev_vals$ymax - prev_vals$ymin
          prevW = prev_vals$xmax - prev_vals$xmin
          # print(paste0("newH: ",newH,"; prevH: ",prevH,
          #              "; newW: ",newW,"; prevW: ", prevW))
          # print(paste0("Res: ", (newH - prevH) + (newW - prevW) ))
          if( abs((newH - prevH) + (newW - prevW)) > 1 )
          {
            NumberOfPlanes$N = 1
            PanelStructures$data <- data.frame(SampleName = "1",vals)
          }else{
            PanelStructures$data <- rbind(PanelStructures$data,
                                          cbind(data.frame(
                                            SampleName = paste(nrow(PanelStructures$data)+1) ),
                                            vals))
          }
        }else{
          PanelStructures$data <- rbind(PanelStructures$data,
                                        cbind(data.frame(
                                          SampleName = paste(nrow(PanelStructures$data)+1) ),
                                          vals))
        }
        prev_vals <<- vals
      }
    }
  })
  
  observeEvent(input$ResetPan,{
    NumberOfPlanes$N = 1
    PanelStructures$data <- PanelData
  })
  
  output$rectCoordOutput <- renderText({
    xy_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("x=", round(e$x, 1), " y=", round(e$y, 1), "\n")
    }
    xy_range_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("xmin=", round(e$xmin, 1), " xmax=", round(e$xmax, 1), 
             " ymin=", round(e$ymin, 1), " ymax=", round(e$ymax, 1))
    }
    
    paste0(
      "Mouse hover: ", xy_str(input$plot_hover),
      "New band coordinates: ", xy_range_str(input$plot_brush)
    )
    
  })
  
  ## Profile plots
  
  output$PlanesStructureTable <- renderDT(
    {
      datatable(PanelStructures$data,
                editable = list(target = "cell", 
                                disable = list(columns = 1:4)),
                options = list(lengthChange = FALSE, autoWidth = TRUE),
                rownames= FALSE
      )
    }
  )
  
  # check names Planes
  observeEvent(input$PlanesStructureTable_cell_edit, {
    cells = input$PlanesStructureTable_cell_edit
    
    data = PanelStructures$data %>% filter(SampleName == PanelStructures$data[cells$row,"SampleName"])
    
    # we check that the same LANE should not have same names.
    if(cells$value %in% data$SampleName){
      k = table(data$SampleName)[cells$value]
      cells$value = paste0(cells$value, " (",k,")")
    }
    cells$col = 1
    
    PanelStructures$data <- editData( PanelStructures$data , cells, 'PlanesStructureTable')
    wbResult$Planes = PanelStructures$data
  })
  
  observeEvent(wbResult$AUCdf,{
    output$AUC <-  renderDT({
      wbResult$AUCdf %>%
        dplyr::select(SampleName,Truncation, AUC)
    },
    selection = 'none',
    rownames= FALSE)
  })
  
  
  #observeEvent(list(input$GenLanes,wbResult$Planes),{
  observeEvent(input$GenLanes,{
    if(NumberOfPlanes$N >1){
      Planes = PanelStructures$data
      Planes[,-1] = round(Planes[,-1])
      wbResult$Planes = Planes
      print(Planes)
      Flags$LanesCut= T
    }else{
      Flags$LanesCut= F
    }
    
    if(Flags$LanesCut)
    {
      updateTabsetPanel(session, "SideTabs",
                        selected = "grey")
      
      im = wbResult$Im$WB
      PanelData = wbResult$Planes
      
      PanelsValue = do.call("rbind",
                            lapply(1:dim(PanelData)[1],
                                   function(i,im,PanelData){
                                     p = PanelData[i,]
                                     Nrow = dim(im)[1]
                                     Ncol= dim(im)[2]
                                     plane = abs(im[(Nrow-p$ymax):(Nrow-p$ymin),p$xmin:p$xmax]-1)
                                     #imageShow(plane)
                                     GreyPlane = apply(plane,1,"mean")
                                     data.frame(Values = GreyPlane,# - min(GreyPlane),
                                                ID = paste0(i,". ",p$SampleName),
                                                Y = 1:length(GreyPlane) )
                                   },
                                   im,PanelData)
                            )
      
      
      pl <- ggplot(PanelsValue, aes(x =Y,y=Values)) +
        geom_line() + 
        theme_bw() +
        facet_wrap(~ID) + 
        lims(y=c(0,max(PanelsValue$Values)))
      
      wbResult$PanelsValue <- PanelsValue
      wbResult$Plots <- pl
      
      updateSelectInput(session, "LaneChoice",
                        choices = unique(PanelsValue$ID),
                        selected = 0
      )
      
      output$DataPlot <- renderPlot({pl})
      
      ### AUC calculation of the whole lane without cuts:
      aucList = lapply(unique(PanelsValue$ID), function(IDlane) AUCfunction(wbResult0$AUCdf,PanelsValue,SName = IDlane) )
      wbResult$AUCdf <- do.call(rbind,aucList)
    }
  })
  
  # reset all the truncation analysis
  observeEvent(input$actionButton_ResetPlanes,{
    
    wbResult$AUCdf =  wbResult$AUCdf %>% filter(Truncation == "-") 
    wbResult$TruncatedPanelsValue = wbResult0$TruncatedPanelsValue
    wbResult$TruncatedPlots = wbResult0$TruncatedPlots 
    
    output$AUC <-  renderDT({wbResult$AUCdf %>%
        dplyr::select(SampleName,Truncation, AUC)},
        selection = 'none', 
        rownames= FALSE,
        # editable = list(target = "cell", 
        #                 disable = list(columns = 1:4))
    )
    
    output$DataPlot <- renderPlot({wbResult$Plots})
    
  })
  
  observeEvent(list(input$LaneChoice),{
    if(Flags$LanesCut & !is.null(wbResult$PanelsValue))
    {
      if(!is.null(wbResult$TruncatedPanelsValue ))
      {
        pl <- wbResult$TruncatedPlots    
        wbResult$TruncatedPanelsValue -> PanelsValue
      }
      else{
        wbResult$PanelsValue -> PanelsValue
        pl<-wbResult$Plots
      }
      
      Plots.Lane <- PanelsValue[which(PanelsValue$ID == input$LaneChoice),]
      colnames(Plots.Lane) = c("Y","ID","X")
      
      cat(input$LaneChoice,"\n")
      updateSliderInput(session,"truncV",
                        min = min(Plots.Lane$X),
                        max = max(Plots.Lane$X),
                        value = c(min(Plots.Lane$X), max(Plots.Lane$X) ) ) 
      updateSliderInput(session,"truncH",
                        min = round(min(Plots.Lane$Y),digits = 3),
                        max = round(max(Plots.Lane$Y),digits = 3),
                        value = round(min(Plots.Lane$Y),digits = 3) )
      
    }
    
  } )  
  
  observe({  Flags$CutTab <- input$tabs })
  
  observeEvent(c(input$truncV,input$truncH,input$LaneChoice), {
    if(!is.null(wbResult$PanelsValue))
    {
      if(!is.null(wbResult$TruncatedPanelsValue ))
      {
        pl <- wbResult$TruncatedPlots    
        wbResult$TruncatedPanelsValue -> PanelsValue
      }
      else{
        wbResult$PanelsValue -> PanelsValue
        pl<-wbResult$Plots
      }
      
      IDlane = input$LaneChoice
      Flags$IDlane <- IDlane
      
      if(Flags$CutTab=="V")
      {
        MinTrunc<-input$truncV[1]
        MaxTrunc<-input$truncV[2]
        
        vline.dat <- data.frame( ID = as.factor(rep(PanelsValue$ID,2)),
                                 vl = 0 )
        
        vline.dat  <-  vline.dat[ vline.dat$ID == IDlane, ]
        vline.dat$vl <- c(MinTrunc,MaxTrunc)
        
        pl <- pl + geom_vline(data=vline.dat,aes(xintercept=vl),linetype="dashed")
      }else if(Flags$CutTab=="H")
      {
        TruncY<-input$truncH[1]
        hline.dat <- data.frame(ID=as.factor(PanelsValue$ID), hl =min(PanelsValue$Y))
        hline.dat  <-  hline.dat[ hline.dat$ID == IDlane, ]
        hline.dat$hl <- TruncY
        
        pl <- pl + geom_hline(data=hline.dat,aes(yintercept = hl),linetype="dashed")
      }
      
      output$DataPlot <- renderPlot({pl})
      
      ### AUC calculation of the whole lane without cuts:
      # wbResult$AUCdf <- AUCfunction(wbResult$AUCdf,PanelsValue,SName = IDlane)
    }  
  })
  
  observeEvent(c(input$actionButton_TruncV,input$actionButton_TruncH),{
    
    if( !is.null(wbResult$PanelsValue))
    {
      Flags$IDlane -> IDlane
      if(!is.null(wbResult$TruncatedPanelsValue ))
      {
        pl <- wbResult$TruncatedPlots    
        wbResult$TruncatedPanelsValue -> PanelsValue
      }
      else{
        wbResult$PanelsValue -> PanelsValue
        pl<-wbResult$Plots
      }
      
      maxPanelsValue=max(wbResult$PanelsValue$Values)
      wbResult$AUCdf -> AUCdf
      AUCdf.new <- AUCdf[length(AUCdf$Truncation),]
      #AUCdf.new$ExpName = "-"
      lastTrunc = AUCdf %>% 
        group_by(SampleName) %>%
        filter(SampleName == IDlane, row_number()==n() ) %>%
        ungroup() %>%
        dplyr::select(Truncation) 
      
      if(length(lastTrunc$Truncation) > 0 & lastTrunc$Truncation != "-")
        AUCdf.new$Truncation <- lastTrunc$Truncation
      
      AUCdf.new$SampleName <- IDlane
      
      if(Flags$CutTab=="V")
      {
        MinTrunc<-input$truncV[1]
        MaxTrunc<-input$truncV[2]
        AUCdf.new$Truncation <- paste(AUCdf.new$Truncation ,";\n X = [", MinTrunc," ; ", MaxTrunc ,"]",collapse = "")
        PanelsValue<- PanelsValue[!((PanelsValue$Y < MinTrunc | PanelsValue$Y > MaxTrunc) & PanelsValue$ID == IDlane),]
        PanelsValue$Values[PanelsValue$ID == IDlane] <- PanelsValue$Values[PanelsValue$ID == IDlane] -min(PanelsValue$Values[PanelsValue$ID == IDlane]) 
        # pl <- ggplot(PanelsValue, aes(x =Y,y=Values)) +
        #   geom_line() + theme_bw() +
        #   facet_wrap(~ID)
        updateSliderInput(session,"truncV",
                          min = min(PanelsValue$Y[PanelsValue$ID == IDlane]),
                          max = max(PanelsValue$Y[PanelsValue$ID == IDlane]),
                          value = c(min(PanelsValue$Y[PanelsValue$ID == IDlane]),
                                    max(PanelsValue$Y[PanelsValue$ID == IDlane]) ) )
      }
      else if(Flags$CutTab=="H")
      {
        TruncY<-input$truncH[1]
        PanelsValue <- PanelsValue[!(PanelsValue$Values<TruncY & PanelsValue$ID == IDlane),]
        PanelsValue$Values[PanelsValue$ID == IDlane] <- PanelsValue$Values[PanelsValue$ID == IDlane] - TruncY
        AUCdf.new$Truncation <- paste(AUCdf.new$Truncation ,";\n Y = ", TruncY)
        # pl <- ggplot(PanelsValue, aes(x =Y,y=Values)) +
        #   geom_line() + 
        #   theme_bw() +
        #   facet_wrap(~ID)+ 
        #   lims(y=c(minPanelsValue,maxPanelsValue))
        
        updateSliderInput(session,"truncH",
                          min = min(PanelsValue$Values[PanelsValue$ID == IDlane]),
                          max = max(PanelsValue$Values[PanelsValue$ID == IDlane]),
                          value = c(min(PanelsValue$Values[PanelsValue$ID == IDlane]),
                                    max(PanelsValue$Values[PanelsValue$ID == IDlane]) ) )
      }
      
      pl <- ggplot(PanelsValue, aes(x =Y,y=Values)) +
        geom_line() + 
        theme_bw() +
        facet_wrap(~ID)+ 
        lims(y=c(0,maxPanelsValue))
      
      wbResult$TruncatedPanelsValue <- PanelsValue
      wbResult$TruncatedPlots <- pl
      output$DataPlot <- renderPlot({pl})
      AUCdf<-AUCfunction(AUCdf.new=AUCdf.new,wbResult$AUCdf,PanelsValue,SName = IDlane)
      
      output$AUC <- renderDT({
        AUCdf  %>% 
          dplyr::select(SampleName,Truncation, AUC) 
      },
      selection = 'none', 
      rownames= FALSE
      # editable = list(target = "cell", 
      #                 disable = list(columns = 1:4))
      )
      wbResult$AUCdf <- AUCdf
    }
  })

  ## next buttons
  observeEvent(input$NextWBQuantif,{
    if(!is.null(wbResult$AUCdf))
      wbquantResult$WBanalysis = reactiveValuesToList(wbResult)
    
    updateTabsetPanel(session, "SideTabs",
                      selected = "quantification")
  })
  
  ## quantification WB
  wbquantResult = reactiveValues(NormWBanalysis = NULL,
                                 NormWBanalysis_filtered = NULL,
                                 WBanalysis = NULL,
                                 WBanalysis_filtered = NULL,
                                 RelDensitiy = NULL,
                                 AdjRelDensitiy = NULL
  )
  wbquantResult0 = list(NormWBanalysis = NULL,
                                 NormWBanalysis_filtered = NULL,
                                 WBanalysis = NULL,
                                 WBanalysis_filtered = NULL,
                                 RelDensitiy = NULL,
                                 AdjRelDensitiy = NULL
  )
  FlagsWBquant = reactiveValues(BothUploaded = F)
  
  # load the two wb analyses
  observeEvent(input$actionB_loadingWB,{
    
    output$LoadingErrorWB <- renderText({
      validate(
        need(!is.null(input$WBImport) && file.exists(input$WBImport$datapath) ,
             "Please select a RDs file!!" )
      )
      
      mess = readfile(
        filename = input$WBImport$datapath,
        type = "RDs",
        namesAll = namesAll
      )
      
      validate(
        need(!setequal(names(mess),c("message","call")) ,
             mess[["message"]])
      )
      
      wbquantResult$WBanalysis = mess
      wbquantResult$WBanalysis_filtered = NULL
      
      "The RDs has been uploaded  with success"
    })
    
  })
  observeEvent(input$actionB_loadingNormWB,{
    output$LoadingErrorNormWB <- renderText({
      validate(
        need(!is.null(input$NormWBImport) && file.exists(input$NormWBImport$datapath) ,
             "Please select a RDs file!!" )
      )
      
      mess = readfile(
        filename = input$NormWBImport$datapath,
        type = "RDs",
        namesAll = namesAll
      )
      
      validate(
        need(!setequal(names(mess),c("message","call")) ,
             mess[["message"]])
      )
      
      validate(
        need(!is.null(mess$AUCdf) ,
             "The WB analysis must contain the AUC table")
      )
      
      choices = paste0(mess$AUCdf$SampleName, " with ", mess$AUCdf$Truncation)
      
      wbquantResult$NormWBanalysis  = mess
      
      "The RDs has been uploaded  with success"
    })
    
  })
  
  observe({
    if(!is.null(wbquantResult$WBanalysis) & !is.null(wbquantResult$NormWBanalysis))
      FlagsWBquant$BothUploaded = T
  })
  
  # update the wb tables
  observe({
    if(is.null(wbquantResult$NormWBanalysis)){
      table = wbResult0$AUCdf
    }else{
      table = wbquantResult$NormWBanalysis$AUCdf
    }
    output$AUC_WBnorm <- renderDT(
      table , 
      #filter = 'top', server = FALSE, 
      selection = "multiple", 
      # editable = list(target = "cell", 
      #                 disable = list(columns = 1:3)),
      options = list(lengthChange = FALSE, autoWidth = TRUE),
      rownames= FALSE
    )
  })
  observe({
    if(is.null(wbquantResult$WBanalysis)){
      table = wbResult0$AUCdf
    }else{
      table = wbquantResult$WBanalysis$AUCdf
    }
    output$AUC_WB <- renderDT(
      table,
      #filter = 'top', server = FALSE, 
      selection = "multiple", 
      # editable = list(target = "cell", 
      #                 disable = list(columns = 1:3)),
      options = list(lengthChange = FALSE, autoWidth = TRUE),
      rownames= FALSE
    )
  })
  
  # selecting rows
  observeEvent(input$AUC_WB_rows_selected,{
    if(!is.null(wbquantResult$WBanalysis) ){
      indexesWB = input$AUC_WB_rows_selected
      AUCdf = wbquantResult$WBanalysis$AUCdf
      
      if(length(indexesWB) > 0){
        wbquantResult$WBanalysis_filtered = AUCdf[indexesWB,]
      }else{
        wbquantResult$WBanalysis_filtered = AUCdf
      }
    }
  })
  observeEvent(input$AUC_WBnorm_rows_selected,{
    if(!is.null(wbquantResult$NormWBanalysis)){
      indexesWB = input$AUC_WBnorm_rows_selected
      AUCdf = wbquantResult$NormWBanalysis$AUCdf
      
      if(length(indexesWB) > 0){
        wbquantResult$NormWBanalysis_filtered = AUCdf[indexesWB,]
        
        choices = paste0( AUCdf[indexesWB,]$SampleName, "; truncated ", AUCdf[indexesWB,]$Truncation)
        selected = input$IdLaneNorm_RelDens
        updateSelectInput("IdLaneNorm_RelDens",
                          session = session,
                          choices = choices,
                          selected = selected)
      }else{
        wbquantResult$NormWBanalysis_filtered = AUCdf
      }
    }
  })
  
  # the relative density and adjusted is calculated
  observeEvent(list(FlagsWBquant$BothUploaded, input$IdLaneNorm_RelDens,input$AUC_WB_rows_selected,input$AUC_WBnorm_rows_selected),{
    table =  wbResult0$AUCdf 
    
    if(!is.null(wbquantResult$WBanalysis_filtered) & !is.null(wbquantResult$NormWBanalysis_filtered)){
      IdLaneNorm_RelDens = input$IdLaneNorm_RelDens
      IdLaneNorm_RelDens = strsplit(IdLaneNorm_RelDens,
                                    split = "; truncated ")[[1]]
      
      tbWBnorm = wbquantResult$NormWBanalysis_filtered %>%
        filter(SampleName ==IdLaneNorm_RelDens[1],
               Truncation == IdLaneNorm_RelDens[2]) %>%
        rename(AUC_Norm = AUC,
               Truncation_Norm = Truncation,
               SampleName_Norm = SampleName)
      
      tbWB = wbquantResult$WBanalysis_filtered
      
      if(!is.null(tbWBnorm) & !is.null(tbWB) & dim(tbWBnorm)[1]==1 ){
        if(!all(table(tbWB$SampleName)==1) ){
          output$LoadingErrorWB <- renderText({"No rows with equal sample name are allowed"})
        }
        else{ # we admit only one SampleName
          table = tbWB
          table$AUC_Norm = tbWBnorm$AUC_Norm
          table$RelDens = table$AUC/table$AUC_Norm
          table = table %>%
            dplyr::select(SampleName, Truncation, AUC, AUC_Norm, RelDens) 
        }
      }
    }
    
    wbquantResult$RelDensitiy = table
    
    output$AUC_RelDens <- renderDT(
      table,
      filter = 'top',
      server = FALSE,
      options = list(lengthChange = FALSE, autoWidth = TRUE),
      rownames= FALSE
    )
    
  })
  
  observeEvent(list(FlagsWBquant$BothUploaded, input$AUC_WB_rows_selected,input$AUC_WBnorm_rows_selected),{
    table = data.frame(SampleName = "-",
                       Truncation = "-", 
                       Truncation_Norm = "-",
                       AUC = "-", 
                       AUC_Norm = "-",
                       AdjRelDens = "-")
    
    if(!is.null(wbquantResult$WBanalysis_filtered) & !is.null(wbquantResult$NormWBanalysis_filtered)){
      
      tbWB = wbquantResult$WBanalysis_filtered
      tbWBnorm = wbquantResult$NormWBanalysis_filtered
      
      if(!all(table(tbWBnorm$SampleName)==1) ){
        output$LoadingErrorNormWB <- renderText({"No rows with equal sample name are allowed"})
      }else if(!all(table(tbWB$SampleName)==1) ){
        output$LoadingErrorWB <- renderText({"No rows with equal sample name are allowed"})
      }
      else{ # we admit only one SampleName
        
        tbWBnorm = tbWBnorm  %>%
          rename(AUC_Norm = AUC,
                 Truncation_Norm = Truncation)
        
        table = merge(tbWBnorm,tbWB, by = "SampleName" ,all = T )
        
        table$AdjRelDens = table$AUC/table$AUC_Norm
        table = table %>% 
          dplyr::select( SampleName, Truncation, Truncation_Norm, AUC, AUC_Norm, AdjRelDens) 
        
        wbquantResult$AdjRelDensitiy = table
        output$AUC_AdjRelDens <- renderDT(
          table ,
          server = FALSE,
          options = list(lengthChange = FALSE, autoWidth = TRUE),
          rownames= FALSE
        )
        
        if(dim(table)[1] > 1 ){
          barPlotAdjRelDens = table %>% 
            mutate(Normalizer = paste0("Sample: ",SampleName ),
                   WB = paste0("Sample: ",SampleName))  %>%
            ggplot() +
            geom_bar(aes(x = SampleName,
                         y = AdjRelDens,
                         fill = Normalizer ),
                     stat = "identity" ) +
            #facet_grid(~WB)+
            theme_bw()
        }else{
          barPlotAdjRelDens = ggplot()
        }
        output$plot_AdjRelDens <- renderPlot({
          barPlotAdjRelDens
        })
      }
    }
  })
  
  #
  toListenWBquant <- reactive({
    reactiveValuesToList(wbquantResult)
  })
  observeEvent(toListenWBquant(),{
    DataAnalysisModule$wbquantResult = reactiveValuesToList(wbquantResult)
  })
  
  ### End WB analysis ####
  
  #### PCR analysis ####
  
  pcrResult = reactiveValues(
                             Initdata = NULL,
                             selectPCRcolumns = NULL,
                             data = NULL,
                             PCRnorm = NULL,
                             BaselineExp = NULL,
                             plotPRC = NULL,
                             NewPCR = NULL)
  pcrResult0 = list(
                    Initdata = NULL,
                    selectPCRcolumns = NULL,
                    data = NULL,
                    PCRnorm = NULL,
                    BaselineExp = NULL,
                    plotPRC = NULL,
                    NewPCR = NULL)
  
  # save everytime there is a change in the results
  PCRresultListen <- reactive({
    reactiveValuesToList(pcrResult)
  })
  observeEvent(PCRresultListen(), {
    DataAnalysisModule$pcrResult = reactiveValuesToList(pcrResult)
    DataAnalysisModule$pcrResult$Flags = reactiveValuesToList(FlagsPCR)
  })
  
  ## next buttons
  observeEvent(input$NextQuantif,{
    updateTabsetPanel(session, "SideTabs",
                      selected = "tablesPCR")
  })
  observeEvent(input$NextpcrPlots,{
    updateTabsetPanel(session, "SideTabs",
                      selected = "plotsPCR")
  })
  #
  
  FlagsPCR <- reactiveValues(norm=F, 
                             baseline = F)
  
  observeEvent(input$LoadPCR_Button,{
    
    if( !is.null(pcrResult$Initdata) )
    { ### alert!!! if it is already present! 
      showModal(modalDialog(
        title = "Important message",
        "Do you want to update the RT-PCR data already present?",
        easyClose = TRUE,
        footer= tagList(actionButton("confirmUploadPCR", "Update"),
                        modalButton("Cancel")
        )
      ))
    }
    
    output$LoadingError_PCR <- renderText({
      validate(
        need(!is.null(input$PCRImport) && file.exists(input$PCRImport$datapath) ,
             "Please select an RT-qPCR excel file!!" )
      )
      
      mess = readfile(
        filename = input$PCRImport$datapath,
        type = "Excel"
      )
      
      validate(
        need(!setequal(names(mess),c("message","call")) ,
             mess[["message"]] )
      )
      
      pcrResult$Initdata = mess
      
      updateSelectInput(session,"PCR_gene",
                        choices = c("",colnames(pcrResult$Initdata)),
                        selected = ""
      )
      updateSelectInput(session,"PCR_sample",
                        choices = c("",colnames(pcrResult$Initdata)),
                        selected = ""
      )
      updateSelectInput(session,"PCR_value",
                        choices = c("",colnames(pcrResult$Initdata)),
                        selected = ""
      )
      updateSelectInput(session,"PCR_time",
                        choices = c("",colnames(pcrResult$Initdata)),
                        selected = ""
      )
      "The RT-qPCR excel has been uploaded  with success"
    })
  })
  observeEvent(input$confirmUploadPCR,{
    
    pcrResult = pcrResult0
    
    FlagsPCR$norm=F 
    FlagsPCR$baseline = F
    
    output$PCRtables <- renderUI({ NULL })
    output$PCRtablesComp <- renderUI({ NULL })
    output$PCRplot <- renderPlot({ NULL })
    
    output$LoadingError_PCR <- renderText({
      validate(
        need(!is.null(input$PCRImport) && file.exists(input$PCRImport$datapath) ,
             "Please select an RT-PCR excel file!!" )
      )
      
      mess = readfile(
        filename = input$PCRImport$datapath,
        type = "Excel"
      )
      
      validate(
        need(!setequal(names(mess),c("message","call")) ,
             mess[["message"]])
      )
      
      pcrResult$Initdata = mess
      
      updateSelectInput(session,"PCR_gene",
                        choices = c("",colnames(pcrResult$Initdata)),
                        selected = ""
      )
      updateSelectInput(session,"PCR_sample",
                        choices = c("",colnames(pcrResult$Initdata)),
                        selected = ""
      )
      updateSelectInput(session,"PCR_value",
                        choices = c("",colnames(pcrResult$Initdata)),
                        selected = ""
      )
      updateSelectInput(session,"PCR_time",
                        choices = c("",colnames(pcrResult$Initdata)),
                        selected = ""
      )
      
      removeModal()
      
      "The RDs has been uploaded  with success"
    })
  })
  
  
  observeEvent(list(input$PCR_value,input$PCR_gene,input$PCR_sample,input$PCR_time),{
    if( !is.null(pcrResult$Initdata) ){
      selectPCRcolumns = c(input$PCR_gene,input$PCR_sample,input$PCR_value,input$PCR_time)
      selectPCRcolumns = selectPCRcolumns[selectPCRcolumns!= ""]
      
      PCR = pcrResult$Initdata
      colNames = colnames(PCR)
      output$PCRpreview = renderTable({
        if(length(selectPCRcolumns)!=0 ){
          tmp = PCR[,selectPCRcolumns]
          #colnames(tmp) = c("Gene", "Sample", "Value")[1:length(colnames(tmp))]
          head(tmp) 
        }
        else
          NULL
      })
      
      if(length(selectPCRcolumns)==3 ){
        tmp = PCR[,selectPCRcolumns]
        colnames(tmp) = c("Gene", "Sample", "Value")
        tmp$Time = ""
        pcrResult$data = tmp
        pcrResult$selectPCRcolumns = selectPCRcolumns
      }else if(length(selectPCRcolumns)==4 ){
        tmp = PCR[,selectPCRcolumns]
        colnames(tmp) = c("Gene", "Sample", "Value","Time")
        pcrResult$data = tmp
        pcrResult$selectPCRcolumns = selectPCRcolumns
      }else{
        pcrResult$data = NULL
      }
    }
    
  })
  
  observe({
    if(!is.null(pcrResult$data)){
      
      PCR = pcrResult$data
      
      AllGenes = unique(PCR$Gene)
      Exp = unique(PCR$Sample)
      
      updateSelectInput(session, "PCRbaseline",
                        choices = Exp )
      updateCheckboxGroupInput(session,"PCRnorm",
                               choices = AllGenes )
      
    }else{
      updateSelectInput(session, "PCRbaseline",
                        choices = "" )
      updateCheckboxGroupInput(session,"PCRnorm",
                               choices = "" )
    }
  })
  
  observeEvent(input$PCRnorm,{
    pcrResult$PCRnorm = input$PCRnorm
    FlagsPCR$norm = T
  })
  observeEvent(input$PCRbaseline,{
    pcrResult$BaselineExp = input$PCRbaseline
    FlagsPCR$baseline = T
  })
  
  observe({
    if(FlagsPCR$baseline & FlagsPCR$norm & !is.null(pcrResult$data)){
      
      pcrResult$BaselineExp -> BaselineExp
      pcrResult$PCRnorm -> PCRnorm
      pcrResult$data -> PCR
      
      NewPCR = PCR %>% 
        na.omit()%>%
        group_by(Sample,Gene,Time) %>%
        dplyr::summarise(Mean = mean(Value),
                         Sd = sd(Value)) %>%
        ungroup()

      HousekGenePCR = NewPCR %>%
        filter(Gene %in% PCRnorm)%>%
        rename(HousekGene = Gene,HousekGeneMean=Mean, HousekGeneSd=Sd) 
      
      PCRstep2 = merge(HousekGenePCR,NewPCR %>% filter(!Gene %in% PCRnorm),all.y = T,by=c("Sample","Time") )
      
      #PCRstep3 = merge(BaselinePCR,PCRstep2,all.y = T,by=c("Gene","Time") )

      
      PCRstep3 = PCRstep2 %>%
        group_by(Sample,Gene,Time) %>%
        dplyr::mutate(dCt = Mean - HousekGeneMean)%>%
        ungroup()
      
      BaselinePCR = PCRstep3 %>% 
        filter(Sample == BaselineExp) %>%
        rename(BaselineMean=Mean, BaselineSd=Sd,BaselinedCt = dCt) %>%
        dplyr::select(-Sample, -HousekGene, -HousekGeneMean, -HousekGeneSd)
      
      PCRstep4 = merge(BaselinePCR,PCRstep3,all.y = T,by=c("Gene","Time") )
      
      PCRstep5 = PCRstep4 %>%
        group_by(Sample,Gene,Time) %>%
        dplyr::summarize(
          ddCt = dCt - BaselinedCt,
                         Q = 2^{-ddCt},
                         Sd = Sd,
                         Mean = Mean)%>%
        ungroup()

      
      NormPCR = PCRstep5 %>%
        filter(Gene %in% PCRnorm ) %>%
        rename(Norm = Gene,
               NormQ = Q,
               NormSd = Sd,
               NormMean = Mean)
      
      # CompPRC = merge(OnePCR,NormPCR)
      # 
      # CompPRC = CompPRC %>% group_by(Sample,Gene,Norm) %>%
      #   dplyr::summarise(Qnorm = Q/NormQ,
      #                    SDddct = sqrt(Sd^2+NormSd^2),
      #                    SDrq = log(2)*Qnorm*SDddct) %>%
      #   ungroup()
      
      AllGenes = unique(PCR$Gene)
      
      #pcrResult$CompPRC = CompPRC
      pcrResult$NewPCR = PCRstep5
      
      output$PCRtables <- renderUI({
        plot_output_list <- lapply(AllGenes, function(i) {
          tablename <- paste("tablename", i, sep="")
          tableOutput(tablename)
        })
        do.call(tagList, plot_output_list)
      })
      
      # output$PCRtablesComp <- renderUI({
      #   plot_output_list <- lapply(AllGenes[-which(AllGenes %in% PCRnorm)], function(i) {
      #     tablename <- paste("CompTablename", i, sep="")
      #     tableOutput(tablename)
      #   })
      #   do.call(tagList, plot_output_list)
      # })
        
      plot1 = ggplot(data = PCRstep5,
                     aes(x= as.factor(Time), y = ddCt, col = Sample)) + 
        facet_wrap(~Gene, ncol = 1) +
        geom_jitter(width = 0.1, height = 0,size = 2)+
        theme_bw()+
        labs(x = "Time", y = "DDCT")
      
      plot2 = ggplot(data = PCRstep5,
                     aes(x= as.factor(Time), y = Q, col = Sample)) + 
          facet_wrap(~Gene, ncol = 1) +
          geom_jitter(width = 0.1, height = 0,size = 2)+
          theme_bw()+
          labs(x = "Time", y = "2^(-DDCT)")

      pcrResult$plotPRC =  plot1/plot2
      
      output$PCRplot <- renderPlot({
        pcrResult$plotPRC
      })
      
      for (i in AllGenes[!AllGenes %in% PCRnorm]){
        local({
          my_i <- i
          tablename <- paste("tablename", my_i, sep="")
          output[[tablename]] <- renderTable({
            PCRstep5 %>% filter(Gene == my_i) %>% rename(DDCT = ddCt, `2^(-DDCT)` = Q)
          })
          
          # ComparisonPCR = list()
          # if(my_i %in% AllGenes[-which(AllGenes %in% PCRnorm)]){
          #   tablename <- paste("CompTablename", my_i, sep="")
          #   output[[tablename]] <- renderTable({
          #     CompPRC %>% 
          #       filter(Gene == my_i) %>%
          #       arrange(Norm,Sample)
          #   })
          # }
        })    
      }
      
    }
  })
  
  observe({
    DataAnalysisModule$pcrResult = reactiveValuesToList(pcrResult)
  })
  
  #### END PCR analysis ####
  
  ### ENDOC analysis ####
  
  # next buttons
  observeEvent(input$NextEndocQuantif,{
    updateTabsetPanel(session, "SideTabs",
                      selected = "tablesENDOC")
  })
  #
  
  endocResult = reactiveValues(
                               Initdata= NULL,
                               data = NULL,
                               TablePlot = NULL,
                               dataFinal = NULL,
                               ENDOCcell_TIME = NULL,
                               ENDOCcell_SN = NULL,
                               MapBaseline = NULL,
                               MapBlank = NULL)
  
  endocResult0 = list(
                      Initdata= NULL,
                      data = NULL,
                      TablePlot = NULL,
                      dataFinal = NULL,
                      ENDOCcell_TIME = NULL,
                      ENDOCcell_SN = NULL,
                      MapBaseline = NULL,
                      MapBlank = NULL)
  
  # save everytime there is a change in the results
  ENDOCresultListen <- reactive({
    reactiveValuesToList(endocResult)
  })
  observeEvent(ENDOCresultListen(), {
    DataAnalysisModule$endocResult = reactiveValuesToList(endocResult)
    DataAnalysisModule$endocResult$Flags = reactiveValuesToList(FlagsENDOC)
  })
  
  ##
  FlagsENDOC <- reactiveValues(cellCoo = NULL,
                               AllExp = "",
                               BASEselected = "",
                               BLANCHEselected = "",
                               EXPselected = "",
                               EXPcol = NULL)
  
  observeEvent(input$LoadENDOC_Button,{
    output$LoadingError_ENDOC <- renderText({
      validate(
        need(!is.null(input$ENDOCImport) && file.exists(input$ENDOCImport$datapath) ,
             "Please select an ENDOC excel file!!" )
      )
      
      mess = readfile(
        filename = input$ENDOCImport$datapath,
        type = "Excel",
        allDouble = T,
        colname = F,
        colors = T
      )
      
      validate(
        need(!setequal(names(mess),c("message","call")) ,
             mess[["message"]] )
      )
      
      endocResult$Initdata = mess$x
      FlagsENDOC$EXPcol = mess$fill
      endocResult$ENDOCcell_SN = mess$SNtable
      
      "The ENDOC excel has been uploaded  with success"
    })
    
    if( !is.null(endocResult$Initdata) )
    { ### alert!!! if it is already present! 
      showModal(modalDialog(
        title = "Important message",
        "Do you want to update the ENDOC data already present?",
        easyClose = TRUE,
        footer= tagList(actionButton("confirmUploadENDOC", "Update"),
                        modalButton("Cancel")
        )
      ))
      
    }
  })
  observeEvent(input$confirmUploadENDOC,{
    
    for(nameList in names(endocResult0)) 
      endocResult[[nameList]] <- endocResult0[[nameList]]
    
    output$LoadingError_ENDOC <- renderText({
      validate(
        need(!is.null(input$ENDOCImport) && file.exists(input$ENDOCImport$datapath) ,
             "Please select an ENDOC excel file!!" )
      )
      
      mess = readfile(
        filename = input$ENDOCImport$datapath,
        type = "Excel",
        allDouble = T,
        colname = F,
        colors = T
      )
      
      validate(
        need(!setequal(names(mess),c("message","call")) ,
             mess[["message"]])
      )

      endocResult$Initdata = mess$x
      FlagsENDOC$EXPcol = mess$fill
      endocResult$ENDOCcell_SN = mess$SNtable
      
      removeModal()
      
      "The RDs has been uploaded  with success"
    })
  })
  observe({
    if( !is.null(endocResult$Initdata) && is.null(endocResult$TablePlot) ){
     
      tableExcelColored(session = session,
                        Result = endocResult, 
                        FlagsExp = FlagsENDOC,
                        type = "Initialize")
      
      output$ENDOCmatrix <-renderDataTable({endocResult$TablePlot})
      
    }
  })
  observeEvent(input$ENDOCmatrix_cell_clicked,{
    if(length(input$ENDOCmatrix_cell_clicked)!=0){
      cellSelected= as.numeric(input$ENDOCmatrix_cell_clicked)
      FlagsENDOC$cellCoo = cellCoo = c(cellSelected[1],cellSelected[2]+1)
      print(cellCoo)
      print(endocResult$ENDOCcell_TIME[ cellCoo[1],cellCoo[2] ])
      print(endocResult$ENDOCcell_SN[ cellCoo[1], cellCoo[2] ])
      
      updateSelectizeInput(inputId = "ENDOCcell_TIME",
                           selected = ifelse(is.null(endocResult$ENDOCcell_TIME[cellCoo[1],cellCoo[2]]),"",endocResult$ENDOCcell_TIME[cellCoo[1],cellCoo[2]])
      )
      
      updateSelectizeInput(inputId = "ENDOCcell_SN",
                           selected = ifelse(is.null(endocResult$ENDOCcell_SN[cellCoo[1],cellCoo[2]]),
                                             "",
                                             endocResult$ENDOCcell_SN[cellCoo[1],cellCoo[2]])
      )
    }
  })
  
  observeEvent(input$ENDOCcell_TIME,{
    if(!is.null(endocResult$ENDOCcell_TIME)){
      cellCoo = FlagsENDOC$cellCoo
      endocResult$ENDOCcell_TIME[cellCoo[1],cellCoo[2]] = input$ENDOCcell_TIME
    }
  })
  
  observeEvent(input$ENDOCcell_SN,{
    if(!is.null(endocResult$ENDOCcell_SN)){
      ENDOCtb = endocResult$TablePlot
      cellCoo = FlagsENDOC$cellCoo
      if(!is.null(cellCoo)){
        value.bef = endocResult$ENDOCcell_SN[cellCoo[1],cellCoo[2]] 
        value.now = input$ENDOCcell_SN

        # if the value does not change or it is still "Color " then the matrix is not update
        if( value.now != "" && value.now!=value.bef){
         
          endocResult$ENDOCcell_SN[cellCoo[1],cellCoo[2]] = value.now
          ENDOCtb$x$data[cellCoo[1],paste0("Col",cellCoo[2])] = value.now
          
        if(! input$ENDOCcell_SN %in% FlagsENDOC$AllExp){
          exp = unique(c(FlagsENDOC$AllExp,input$ENDOCcell_SN))
          #exp = exp[-grep(pattern = "^Color [1-9]",x = exp)]
          FlagsENDOC$AllExp  = exp
          print(FlagsENDOC$AllExp)
        }
        
        ## updating table and colors definition depending on the cell fill 
        tableExcelColored(session = session,
                          Result = endocResult, 
                          FlagsExp = FlagsENDOC,
                          type = "Update")
        #####
        output$ENDOCmatrix <-renderDataTable({endocResult$TablePlot})
        }
      }
    }
  })
  
  ## update Baselines checkBox
  observeEvent(c(FlagsENDOC$AllExp,FlagsENDOC$BLANCHEselected),{
    if(length(FlagsENDOC$AllExp) > 1){
      exp = FlagsENDOC$AllExp
      exp = exp[exp != ""]
      
      if(!( length(FlagsENDOC$BLANCHEselected) == 1 && FlagsENDOC$BLANCHEselected == "") )
        exp = exp[!exp %in% FlagsENDOC$BLANCHEselected]
      
      exp_selec = input$ENDOC_baselines
      
      updateCheckboxGroupInput(session,"ENDOC_baselines",
                               choices = exp,
                               selected = exp_selec )
      
      FlagsENDOC$EXPselected = exp
      
    }
  })
  
  observeEvent(c(FlagsENDOC$AllExp,FlagsENDOC$BASEselected),{
    if(length(FlagsENDOC$AllExp) > 1){
      exp = FlagsENDOC$AllExp
      exp = exp[exp != ""]
      
      if(! (length(FlagsENDOC$BASEselected) == 1 && FlagsENDOC$BASEselected == "") )
        exp = exp[!exp %in% FlagsENDOC$BASEselected]
      
      exp_selec = input$ENDOC_blanks
      
      updateCheckboxGroupInput(session,"ENDOC_blanks",
                               choices = exp,
                               selected = exp_selec )
      
      FlagsENDOC$EXPselected = exp
    }
  })
  
  ## select the baselines and blank
  observeEvent(input$ENDOC_baselines,{
    FlagsENDOC$BASEselected = input$ENDOC_baselines
    FlagsENDOC$EXPselected = FlagsENDOC$AllExp[! FlagsENDOC$AllExp %in% c(FlagsENDOC$BASEselected,FlagsENDOC$BLANCHEselected)]
  },ignoreNULL = F)
  observeEvent(input$ENDOC_blanks,{
    FlagsENDOC$BLANCHEselected = input$ENDOC_blanks
    FlagsENDOC$EXPselected = FlagsENDOC$AllExp[! FlagsENDOC$AllExp %in% c(FlagsENDOC$BASEselected,FlagsENDOC$BLANCHEselected)]
  },ignoreNULL = F)
  
  toListen_endoc <- reactive({
    exp = FlagsENDOC$EXPselected
    exp = exp[exp != ""]
    if(length(exp) > 0 )
    {
      Input_baselEXP = lapply(exp,
                              function(i) input[[paste0("Exp",i)]])
      Input_blEXP = lapply(unique(exp,FlagsENDOC$BASELINEselected),
                           function(i) input[[paste0("blExp",i)]] )
      InputEXP = c(Input_baselEXP,Input_blEXP)
      
      which(sapply(InputEXP, is.null)) -> indexesEXPnull
      if(length(indexesEXPnull) > 0 )
        listReturn = InputEXP[-indexesEXPnull]
      else
        listReturn = InputEXP
    }else{
      listReturn = list()
    }
    
    if(length(listReturn) == 0){
      return(list("Nothing",endocResult$ENDOCcell_TIME,endocResult$ENDOCcell_SN))
    }else{
      return(c(listReturn,list(endocResult$ENDOCcell_TIME,endocResult$ENDOCcell_SN)) )
    }
  })
  
  observeEvent(toListen_endoc(),{
    baselines = FlagsENDOC$BASEselected
    baselines = baselines[baselines != ""]
    
    if(toListen_endoc()[[1]] != "Nothing"){
      exp = FlagsENDOC$EXPselected
      exp = exp[exp != ""]
      expNotBlank = unique(c(exp,baselines))
      
      MapBaseline = do.call(rbind,
                            lapply(exp,function(i){
                              if( length(input[[paste0("Exp",i)]]) > 0 && input[[paste0("Exp",i)]] != ""){
                                data.frame(Exp = i, Baseline = input[[paste0("Exp",i)]])
                              }else{
                                data.frame(Exp = i, Baseline = NA)
                              }
                            })
      ) %>% na.omit()
      
      MapBlank = do.call(rbind,
                           lapply(expNotBlank,
                                  function(i){
                                    if( length(input[[paste0("blExp",i)]]) > 0 && input[[paste0("blExp",i)]] != ""){
                                      data.frame(Exp = i, Blank = input[[paste0("blExp",i)]])
                                    }else{
                                      data.frame(Exp = i, Blank = NA)
                                    }
                                  })
      ) %>% na.omit()
      
      if(dim(MapBaseline)[1]!=0 && dim(MapBlank)[1]!=0 ){

      endocResult$MapBaseline = MapBaseline
      endocResult$MapBlank = MapBlank
      
      mat = as.matrix(endocResult$Initdata)
      endocV = expand.grid(seq_len(nrow(mat)), seq_len(ncol(mat))) %>%
        rowwise() %>%
        mutate(values = mat[Var1, Var2])
      matTime =  as.matrix(endocResult$ENDOCcell_TIME)
      endocT = expand.grid(seq_len(nrow(matTime)), seq_len(ncol(matTime))) %>%
        rowwise() %>%
        mutate(time = matTime[Var1, Var2])
      matExp =  as.matrix(endocResult$ENDOCcell_SN)
      endocE = expand.grid(seq_len(nrow(matExp)), seq_len(ncol(matExp))) %>%
        rowwise() %>%
        mutate(exp = matExp[Var1, Var2])
      endocTot = merge(endocV,merge(endocT,endocE)) %>%
        filter(exp != "")
      
      endocTotAverage = endocTot %>%
        mutate(time = ifelse(exp %in% MapBlank$Blank, 0, time)) %>%
        group_by(time, exp) %>%
        summarize(meanValues = mean(values))
      
      # merging exp with blank for the substraction
      
      endocTot_bl = right_join( endocTotAverage,MapBlank, 
                                by= c("exp"= "Blank") )%>%
        rename(BlankValues = meanValues, Blank =  exp, exp = Exp )
      
      endocTotAverage = merge( endocTotAverage %>% filter(! exp %in%endocTot_bl$Blank ),
                               endocTot_bl %>% ungroup() %>%
                                 dplyr::select(-time), all.x = T, by = "exp") %>%
        rename(Exp = exp) 
      endocTotAverage = endocTotAverage %>% mutate(meanValues = meanValues - BlankValues )
      
      # merging exp with baseline
      endocTot_base = merge(MapBaseline, endocTotAverage,
                            by.y = "Exp", by.x = "Baseline") %>%
        rename(BaseValues = meanValues) %>% 
        select(-Blank,-BlankValues)
      
      if(length(unique(endocTot_base$time)) == 1){ 
        # if there is only one point then the baseline is used to normalize every times
        endocTot_base = endocTot_base %>% select(-time)
      }
      endocTot_base = merge(endocTotAverage,
                            endocTot_base )
                            # by.x = c("exp","time"),
                            # by.y = c("Exp","time")
                            #)
      endocResult$data = endocTot
      
      if(length(endocTotAverage[,1]) != 0 ){
        endocmean = endocTot_base %>%
          rename( MeanExperiment = meanValues,
                  MeanBaseline = BaseValues ) %>%
          dplyr::mutate(Quantification = MeanExperiment/MeanBaseline * 100) %>%
          rename(Experiment = Exp,Time = time) 
        
        output$ENDOCtables = renderDT(endocmean)
        
        endocResult$dataFinal = endocmean
        
        output$ENDOCplots = renderPlot(
          {
            pl1 = endocmean %>%
              ggplot( aes(x = Time, y = MeanBaseline,
                          col= Baseline, group = Experiment ) )+
              geom_point( )+
              geom_line()+
              theme_bw()+
              labs(x = "Time", col = "Baselines selected",
                   y = "Average Baseline\n quantifications")
            
            pl2 = endocmean %>%
              mutate(ExperimentBaseline = paste0(Experiment,"/",Baseline)) %>%
              ggplot( aes(x = Time, y = Quantification,
                          col= ExperimentBaseline, group = Experiment ) )+
              geom_point()+
              geom_line()+
              theme_bw()+
              labs(x = "Time", col = "Ratio\n Experiment / Baseline",
                   y = "Ratio of the average quantifications\n (as %)")
            
            pl2/pl1
          }
        )
      }else{
        output$ENDOCtables = renderDT(data.frame(Error = "No baseline is associated with the experiment replicants!"))
      }        
      }
    }
  })
  
  # here the Exp boxes are updated every time a new experiment is added 
  observeEvent(FlagsENDOC$EXPselected,{
    expToselect = FlagsENDOC$EXPselected
    baselines =  FlagsENDOC$BASEselected
    blanks = FlagsENDOC$BLANCHEselected
    
    expToselect = expToselect[expToselect != ""]
    
    # baselines updating
    output$EndocBaselineSelection <- renderUI({
      select_output_list <- lapply(expToselect[! expToselect %in% baselines],
                                   function(i) {
                                     if(length(input[[paste0("Exp",i)]])>0)
                                       expsel = input[[paste0("Exp",i)]]
                                     else 
                                       expsel = ""
                                     
                                     selectInput(inputId = paste0("Exp",i),
                                                 label = i,
                                                 choices = c("",baselines),
                                                 selected = expsel)
                                   })
      do.call(tagList, select_output_list)
    })
    # blanks updating
    output$EndocBlankSelection <- renderUI({
      select_output_list <- lapply(unique(c(expToselect,baselines)), function(i) {
        
        if(length(input[[paste0("blExp",i)]])>0)
          expsel = input[[paste0("blExp",i)]]
        else 
          expsel = ""
        
        selectInput(inputId = paste0("blExp",i),
                    label = i,
                    choices = c("",blanks),
                    selected = expsel)
      })
      do.call(tagList, select_output_list)
    })
  })
  
  observeEvent(endocResult$TablePlot, {
    ENDOCtb = endocResult$TablePlot
    output$ENDOCmatrix <- renderDT(
      ENDOCtb,
      server = FALSE
    )
    
    ##### Plot the values selected!
    matTime =  as.matrix(endocResult$ENDOCcell_TIME)
    matExp =  as.matrix(endocResult$ENDOCcell_SN)
    
    if( !( all(matTime == "")  || all(matExp == "") ) ){
      mat = as.matrix(endocResult$Initdata)
      endocV = expand.grid(seq_len(nrow(mat)), seq_len(ncol(mat))) %>%
        rowwise() %>%
        mutate(values = mat[Var1, Var2])
      endocT = expand.grid(seq_len(nrow(matTime)), seq_len(ncol(matTime))) %>%
        rowwise() %>%
        mutate(time = matTime[Var1, Var2])
      endocE = expand.grid(seq_len(nrow(matExp)), seq_len(ncol(matExp))) %>%
        rowwise() %>%
        mutate(exp = matExp[Var1, Var2])
      endocTot = merge(endocV,merge(endocT,endocE)) %>%
        na.omit() %>%
        filter(time != "",  exp != "") 
      
      endocResult$data = endocTot
      
      output$ENDOCinitplots <- renderPlot(
        ggplot(endocTot, aes(x = time, y=values, col = exp),alpha = 1.4) +
          #geom_boxplot(aes(fill= exp, group = time),alpha = 0.4) +
          geom_point(aes(group = exp)) +
          scale_color_manual(values = FlagsENDOC$EXPcol) + 
          #scale_fill_manual(values = FlagsENDOC$EXPcol) + 
          theme_bw()+
          labs(x = "Times", y = "Values", col = "Exp",fill = "Exp")+
          theme(legend.position = c(0, 1), 
                legend.justification = c(0, 1),
                legend.direction = "vertical",
                legend.background = element_rect(size=0.5,
                                                 linetype="solid",
                                                 colour ="black"))
      )
    }
  })
  
  ### End ENDOC analysis ####
  
  ### ELISA analysis ####
  
  # next buttons
  observeEvent(input$NextElisaQuantif,{
    updateTabsetPanel(session, "SideTabs",
                      selected = "tablesELISA")
  })
  #
  
  elisaResult = reactiveValues(
                               Initdata= NULL,
                               data = NULL,
                               TablePlot = NULL,
                               dataFinal = NULL,
                               ELISAcell_EXP = NULL,
                               ELISAcell_SN = NULL,
                               MapBaseline = NULL,
                               MapBlank = NULL,
                               Tablestandcurve = NULL,
                               Regression = NULL)
  
  elisaResult0 = list(
                      Initdata= NULL,
                      data = NULL,
                      TablePlot = NULL,
                      dataFinal = NULL,
                      ELISAcell_EXP = NULL,
                      ELISAcell_SN = NULL,
                      MapBaseline = NULL,
                      MapBlank = NULL,
                      Tablestandcurve = NULL,
                      Regression = NULL)
  
  # save everytime there is a change in the results
  ELISAresultListen <- reactive({
    reactiveValuesToList(elisaResult)
  })
  observeEvent(ELISAresultListen(), {
    DataAnalysisModule$elisaResult = reactiveValuesToList(elisaResult)
    DataAnalysisModule$elisaResult$Flags = reactiveValuesToList(FlagsELISA)
  })
  
  ##
  FlagsELISA <- reactiveValues(cellCoo = NULL,
                               AllExp = "",
                               BASEselected = "",
                               STDCselected = "",
                               BLANCHEselected = "",
                               EXPselected = "",
                               EXPcol = NULL)
  
  observeEvent(input$LoadELISA_Button,{
    output$LoadingError_ELISA <- renderText({
      validate(
        need(!is.null(input$ELISAImport) && file.exists(input$ELISAImport$datapath) ,
             "Please select an ELISA excel file!!" )
      )
      
      mess = readfile(
        filename = input$ELISAImport$datapath,
        type = "Excel",
        allDouble = T,
        colname = F
      )
      
      validate(
        need(!setequal(names(mess),c("message","call")) ,
             mess[["message"]] )
      )
      
      elisaResult$Initdata = mess
      
      "The ELISA excel has been uploaded  with success"
    })
    
    if( !is.null(elisaResult$Initdata) )
    { ### alert!!! if it is already present! 
      showModal(modalDialog(
        title = "Important message",
        "Do you want to update the ELISA data already present?",
        easyClose = TRUE,
        footer= tagList(actionButton("confirmUploadELISA", "Update"),
                        modalButton("Cancel")
        )
      ))
      
    }
  })
  observeEvent(input$confirmUploadELISA,{
    removeModal()
    
    for(nameList in names(elisaResult0)) 
      elisaResult[[nameList]] <- elisaResult0[[nameList]]
    
    output$LoadingError_ELISA <- renderText({
      validate(
        need(!is.null(input$ELISAImport) && file.exists(input$ELISAImport$datapath) ,
             "Please select an ELISA excel file!!" )
      )
      
      mess = readfile(
        filename = input$ELISAImport$datapath,
        type = "Excel"
      )
      
      validate(
        need(!setequal(names(mess),c("message","call")) ,
             mess[["message"]])
      )
      
      elisaResult$Initdata = mess
      "The RDs has been uploaded  with success"
    })
  })
  observe({
    if( !is.null(elisaResult$Initdata) && is.null(elisaResult$TablePlot) ){
      ELISAtb = elisaResult$Initdata
      
      ELISAtb.colors = ELISAtb
      ELISAtb.colors[,] = ""
      mELISA  =cbind(ELISAtb,ELISAtb.colors)
      
      cols.keep <- paste0('V',1:length(ELISAtb[1,])) 
      cols.color <- paste0('Col',1:length(ELISAtb[1,]))
      
      colnames(mELISA) = c(cols.keep,cols.color)
      
      ELISAtb = datatable(mELISA,
                          filter = 'none',
                          #server = FALSE,
                          selection = list(mode = 'single', target = 'cell'),
                          rownames= FALSE,
                          options = list(
                            #lengthChange = FALSE,
                            #scrollX = TRUE,
                            columnDefs = list(list(targets = cols.color, 
                                                   visible = FALSE))
                          )) %>%
        formatStyle(cols.keep,
                    cols.color,
                    backgroundColor = styleEqual("", 'white'))
      
      ELISA = ELISAtb$x$data
      
      output$ELISAmatrix <-renderDataTable({ELISAtb} 
                                           #options = list(scrollX = TRUE)
      )
      # renderDataTable(
      #   ELISAtb,
      #   #filter = 'none',
      #   server = FALSE,
      #   options=list(scrollX=T)
      #   #selection = list(mode = 'single', target = 'cell'),
      #   #options = list(lengthChange = FALSE ),
      #   #rownames= FALSE
      # )
      
      ELISAcell_SN <- ELISAcell_EXP <- matrix(
        "",
        nrow = length(ELISA[,1]),
        ncol = length(ELISA[1,])
      )
      elisaResult$ELISAcell_SN <- ELISAcell_SN
      elisaResult$ELISAcell_EXP<- ELISAcell_EXP
      elisaResult$TablePlot = ELISAtb
    }
  })
  observeEvent(input$ELISAmatrix_cell_clicked,{
    if(length(input$ELISAmatrix_cell_clicked)!=0){
      cellSelected= as.numeric(input$ELISAmatrix_cell_clicked)
      FlagsELISA$cellCoo = cellCoo = c(cellSelected[1],cellSelected[2]+1)
      print(cellCoo)
      print(elisaResult$ELISAcell_EXP[ cellCoo[1],cellCoo[2] ])
      print(elisaResult$ELISAcell_SN[ cellCoo[1], cellCoo[2] ])
      updateSelectizeInput(inputId = "ELISAcell_EXP",
                           selected = ifelse(is.null(elisaResult$ELISAcell_EXP[cellCoo[1],cellCoo[2]]),
                                             "",
                                             elisaResult$ELISAcell_EXP[cellCoo[1],cellCoo[2]])
      )
      updateSelectizeInput(inputId = "ELISAcell_SN",
                           selected = ifelse(is.null(elisaResult$ELISAcell_SN[cellCoo[1],cellCoo[2]]),
                                             "",
                                             elisaResult$ELISAcell_SN[cellCoo[1],cellCoo[2]])
      )
    }
  })
  
  observeEvent(input$ELISAcell_EXP,{
    if(!is.null(elisaResult$ELISAcell_EXP)){
      cellCoo = FlagsELISA$cellCoo
      elisaResult$ELISAcell_EXP[cellCoo[1],cellCoo[2]] = input$ELISAcell_EXP
    }
  })
  observeEvent(input$ELISAcell_SN,{
    if(!is.null(elisaResult$ELISAcell_SN)){
      ELISAtb = elisaResult$TablePlot
      cellCoo = FlagsELISA$cellCoo
      if(!is.null(cellCoo)){
        elisaResult$ELISAcell_SN[cellCoo[1],cellCoo[2]] = input$ELISAcell_SN
        ELISAtb$x$data[cellCoo[1],paste0("Col",cellCoo[2])] = input$ELISAcell_SN
        
        if(! input$ELISAcell_SN %in% FlagsELISA$AllExp){
          FlagsELISA$AllExp = unique(c(FlagsELISA$AllExp,input$ELISAcell_SN))
          print(FlagsELISA$AllExp)
        }
        
        EXPcol = rainbow(n = length(FlagsELISA$AllExp),alpha = 0.4)
        names(EXPcol) = FlagsELISA$AllExp
        EXPcol[names(EXPcol) == ""] = "white"
          FlagsELISA$EXPcol = EXPcol
          print(FlagsELISA$EXPcol)
          cols.color = grep(x = colnames(ELISAtb$x$data),pattern = "Col",value = T)
          cols.keep = grep(x = colnames(ELISAtb$x$data),pattern = "V",value = T)
          elisaResult$TablePlot = datatable(ELISAtb$x$data,
                                            filter = 'none',
                                            #server = FALSE,
                                            selection = list(mode = 'single', target = 'cell'),
                                            rownames= FALSE,
                                            options = list(
                                              #scrollX = TRUE,
                                              #lengthChange = FALSE,
                                              columnDefs = list(list(targets = cols.color, visible = FALSE))
                                            )) %>%
            formatStyle(cols.keep,
                        cols.color,
                        backgroundColor = styleEqual(names(EXPcol), EXPcol))
          
      }
    }
  })
  
  ## update Baselines checkBox
  observeEvent(c(FlagsELISA$AllExp,FlagsELISA$BASEselected,FlagsELISA$BLANCHEselected),{
    if(length(FlagsELISA$AllExp) > 1){
      exp = FlagsELISA$AllExp
      exp = exp[exp != ""]
      
      bool.tmp = exp %in% unique(c(FlagsELISA$BLANCHEselected,FlagsELISA$BASEselected))
      if( length(bool.tmp) > 0  )
        exp = exp[!bool.tmp]
      
      updateSelectizeInput(session,"ELISA_standcurve",
                           choices = exp,
                           selected = ifelse(FlagsELISA$STDCselected %in% exp,FlagsELISA$STDCselected,"") 
      )
    }
  })
  observeEvent(c(FlagsELISA$AllExp,FlagsELISA$BASEselected,FlagsELISA$STDCselected),{
    if(length(FlagsELISA$AllExp) > 1){
      exp = FlagsELISA$AllExp
      exp = exp[exp != ""]
      
      bool.tmp = exp %in% unique(c(FlagsELISA$STDCselected,FlagsELISA$BASEselected))
      if( length(bool.tmp) > 0  )
        exp = exp[!bool.tmp]
      
      updateCheckboxGroupInput(session,"ELISA_blanks",
                               choices = exp,
                               selected = FlagsELISA$BLANCHEselected )
    }
  })
  observeEvent(c(FlagsELISA$AllExp,FlagsELISA$BLANCHEselected,FlagsELISA$STDCselected),{
    if(length(FlagsELISA$AllExp) > 1){
      exp = FlagsELISA$AllExp
      exp = exp[exp != ""]
      
      bool.tmp = exp %in% unique(c(FlagsELISA$STDCselected,FlagsELISA$BLANCHEselected))
      if( length(bool.tmp) > 0  )
        exp = exp[!bool.tmp]
      
      exp_selec = input$ELISA_baselines
      
      updateCheckboxGroupInput(session,"ELISA_baselines",
                               choices = exp,
                               selected = FlagsELISA$BASEselected )
    }
  })
  
  ## select the baselines, std curves, and blank
  observeEvent(input$ELISA_baselines,{
    FlagsELISA$BASEselected = input$ELISA_baselines
    FlagsELISA$EXPselected = FlagsELISA$AllExp[! FlagsELISA$AllExp %in% c(FlagsELISA$STDCselected,FlagsELISA$BASEselected,FlagsELISA$BLANCHEselected)]
  },ignoreNULL = F)
  observeEvent(input$ELISA_standcurve,{
    FlagsELISA$STDCselected = input$ELISA_standcurve
    FlagsELISA$EXPselected = FlagsELISA$AllExp[! FlagsELISA$AllExp %in% c(FlagsELISA$STDCselected,FlagsELISA$BASEselected,FlagsELISA$BLANCHEselected)]
  },ignoreNULL = F)
  observeEvent(input$ELISA_blanks,{
    FlagsELISA$BLANCHEselected = input$ELISA_blanks
    FlagsELISA$EXPselected = FlagsELISA$AllExp[! FlagsELISA$AllExp %in% c(FlagsELISA$STDCselected,FlagsELISA$BASEselected,FlagsELISA$BLANCHEselected)]
  },ignoreNULL = F)
  
  toListen_elisa <- reactive({
    exp = FlagsELISA$EXPselected
    exp = exp[exp != ""]
    if(length(exp) > 0 )
    {
      Input_baselEXP = lapply(exp,
                              function(i) input[[paste0("elisa_Exp",i)]])
      Input_blEXP = lapply(unique(exp,FlagsELISA$BASELINEselected),
                           function(i) input[[paste0("elisa_blExp",i)]] )
      InputEXP = c(Input_baselEXP,Input_blEXP)
      
      which(sapply(InputEXP, function(x) 
        ifelse(is.null(x), T, ifelse(x == "", T, F) ) ) ) -> indexesEXPnull
      
      if(length(indexesEXPnull) > 0 )
        listReturn = InputEXP[-indexesEXPnull]
      else
        listReturn = InputEXP
    }else{
      listReturn = list()
    }
    
    if(length(listReturn) == 0){
      return(list("Nothing",elisaResult$ELISAcell_EXP,elisaResult$ELISAcell_SN))
    }else{
      return(c(listReturn,list(elisaResult$ELISAcell_EXP,elisaResult$ELISAcell_SN)) )
    }
  })
  observeEvent(toListen_elisa(),{
    baselines = FlagsELISA$BASEselected
    baselines = baselines[baselines != ""]
    
    if(toListen_elisa()[[1]] != "Nothing" ){
      exp = FlagsELISA$EXPselected
      exp = exp[exp != ""]
      expNotBlank = unique(c(exp,baselines))
      
      MapBaseline = do.call(rbind,
                            lapply(exp,function(i){
                              if( length(input[[paste0("elisa_Exp",i)]]) > 0 && input[[paste0("elisa_Exp",i)]] != ""){
                                data.frame(Exp = i, Baseline = input[[paste0("elisa_Exp",i)]])
                              }else{
                                data.frame(Exp = i, Baseline = NA)
                              }
                            })
      ) %>% na.omit()
      
      MapBlank = do.call(rbind,
                           lapply(expNotBlank,
                                  function(i){
                                    if( length(input[[paste0("elisa_blExp",i)]]) > 0 && input[[paste0("elisa_blExp",i)]] != ""){
                                      data.frame(Exp = i, Blank = input[[paste0("elisa_blExp",i)]])
                                    }else{
                                      data.frame(Exp = i, Blank = NA)
                                    }
                                  })
      ) %>% na.omit()
      
      elisaResult$MapBaseline = MapBaseline
      elisaResult$MapBlank = MapBlank
      
      mat = as.matrix(elisaResult$Initdata)
      elisaV = expand.grid(seq_len(nrow(mat)), seq_len(ncol(mat))) %>%
        rowwise() %>%
        mutate(values = mat[Var1, Var2])
      matTime =  as.matrix(elisaResult$ELISAcell_EXP)
      elisaT = expand.grid(seq_len(nrow(matTime)), seq_len(ncol(matTime))) %>%
        rowwise() %>%
        mutate(time = matTime[Var1, Var2])
      matExp =  as.matrix(elisaResult$ELISAcell_SN)
      elisaE = expand.grid(seq_len(nrow(matExp)), seq_len(ncol(matExp))) %>%
        rowwise() %>%
        mutate(exp = matExp[Var1, Var2])
      elisaTot = merge(elisaV,merge(elisaT,elisaE)) %>%
        filter(exp != "")
      
      elisaTotAverage = elisaTot %>%
        #mutate(time = ifelse(exp %in% MapBlank$Blank, 0, time)) %>%
        group_by(time, exp) %>%
        summarize(meanValues = mean(values))
      
      # merging exp with blank for the substraction
      
      elisaTot_bl = right_join( elisaTotAverage,MapBlank, 
                                by= c("exp"= "Blank") )%>%
        rename(BlankValues = meanValues, Blank =  exp, exp = Exp )
      
      elisaTotAverage = merge( elisaTotAverage %>% filter( exp %in%elisaTot_bl$exp ),
                               elisaTot_bl %>% ungroup(),all.x = T, by = c("exp","time") ) 
      elisaTotAverage[is.na(elisaTotAverage[,])] = 0
      elisaTotAverage = elisaTotAverage %>% mutate(meanValues = meanValues - BlankValues )
      
      # merging exp with baseline
      elisaTot_base = merge(MapBaseline, elisaTotAverage,
                            by.y = "exp", by.x = "Baseline",all = T) %>%
        rename(BaseValues = meanValues) %>% select(-Blank,-BlankValues)
      
      elisaTot_base = merge(elisaTotAverage, elisaTot_base, 
                            by.x = c("exp","time"), by.y = c("Exp","time"),
                            all.x = T  )
      
      elisaResult$data = elisaTot
      
      if(length(elisaTot_base[,1]) != 0 && !is.null(elisaResult$Regression) ){
        
        elisamean = elisaTot_base %>%
          rename( MeanExperiment = meanValues,
                  MeanBaseline = BaseValues ) %>%
          dplyr::mutate(Quantification =  elisaResult$Regression$fun(MeanExperiment) ) %>%
          #MeanExperiment/MeanBaseline * 100) %>%
          rename(Experiment = exp,Time = time) 
        
        output$ELISAtables = renderDT(elisamean)
        
        elisaResult$dataFinal = elisamean
        
        output$ELISAplots = renderPlot(
          {
            elisamean %>%
              ggplot( aes(x = Time, y = Quantification,
                          fill= Experiment, group = Experiment ) )+
              geom_bar(position = "dodge",stat = "identity")+
              theme_bw()+
              labs(x = "Time", col = "Experiments",
                   y = "Average quantifications obtained\n from the lm ")
          }
        )
      }else{
        output$ELISAtables = renderDT(data.frame(Error = "No linear model!"))
      }
    }
  })
  
  # here the Exp boxes are updated every time a new experiment is added 
  observeEvent(FlagsELISA$EXPselected,{
    expToselect = FlagsELISA$EXPselected
    baselines =  FlagsELISA$BASEselected
    blanks = FlagsELISA$BLANCHEselected
    
    expToselect = expToselect[expToselect != ""]
    
    # baselines updating
    output$ElisaBaselineSelection <- renderUI({
      select_output_list <- lapply(expToselect[! expToselect %in% baselines],
                                   function(i) {
                                     if(length(input[[paste0("elisa_Exp",i)]])>0)
                                       expsel = input[[paste0("elisa_Exp",i)]]
                                     else 
                                       expsel = ""
                                     
                                     selectInput(inputId = paste0("elisa_Exp",i),
                                                 label = i,
                                                 choices = c("",baselines),
                                                 selected = expsel)
                                   })
      do.call(tagList, select_output_list)
    })
    # blanks updating
    output$ElisaBlankSelection <- renderUI({
      select_output_list <- lapply(unique(c(expToselect,baselines)), function(i) {
        
        if(length(input[[paste0("elisa_blExp",i)]])>0)
          expsel = input[[paste0("elisa_blExp",i)]]
        else 
          expsel = ""
        
        selectInput(inputId = paste0("elisa_blExp",i),
                    label = i,
                    choices = c("",blanks),
                    selected = expsel)
      })
      do.call(tagList, select_output_list)
    })
  })
  observeEvent(c(elisaResult$TablePlot,elisaResult$ELISAcell_EXP),
               {
                 ELISAtb = elisaResult$TablePlot
                 output$ELISAmatrix <-renderDataTable({ELISAtb})
                 
                 ##### Plot the values selected!
                 matTime =  as.matrix(elisaResult$ELISAcell_EXP)
                 matExp =  as.matrix(elisaResult$ELISAcell_SN)
                 
                 if( !( all(matTime == "")  || all(matExp == "") ) ){
                   mat = as.matrix(elisaResult$Initdata)
                   elisaV = expand.grid(seq_len(nrow(mat)), seq_len(ncol(mat))) %>%
                     rowwise() %>%
                     mutate(values = mat[Var1, Var2])
                   elisaT = expand.grid(seq_len(nrow(matTime)), seq_len(ncol(matTime))) %>%
                     rowwise() %>%
                     mutate(time = matTime[Var1, Var2])
                   elisaE = expand.grid(seq_len(nrow(matExp)), seq_len(ncol(matExp))) %>%
                     rowwise() %>%
                     mutate(exp = matExp[Var1, Var2])
                   elisaTot = merge(elisaV,merge(elisaT,elisaE)) %>%
                     na.omit() %>%
                     filter(time != "",  exp != "") 
                   
                   elisaResult$data = elisaTot
                 }
               })
  
  ##  regression standard curve
  observeEvent(input$ELISA_standcurve,{
    elisaResult$data -> data
    
    if(input$ELISA_standcurve != ""){
      
      standcurve = data %>%
        filter(exp %in% input$ELISA_standcurve) %>%
        # group_by(exp,time) %>%
        # summarise(AverageMeasures = mean(values)) %>%
        # ungroup() %>%
        select(exp,time,values) %>%
        rename(Measures = values) %>%
        mutate(Concentrations = NA )
      
      # If nothing changes w..r.t. the already saved table then I keep the old one!
      if(!is.null(elisaResult$Tablestandcurve) && 
         all.equal(elisaResult$Tablestandcurve %>% select(-Concentrations),
                   standcurve  %>% select(-Concentrations) ))
      {
        standcurve =  elisaResult$Tablestandcurve
      }else{
        elisaResult$Tablestandcurve = standcurve
      }
      
      
      output$ELISA_Table_stdcurve <- DT::renderDataTable({
        DT::datatable( standcurve,
                       selection = 'none',
                       editable = list(target = "cell",
                                       disable = list(columns = 0:2) ),
                       #options = list(lengthChange = FALSE, autoWidth = TRUE),
                       rownames= FALSE
        )
      })
    } 
  })
  observeEvent(elisaResult$Tablestandcurve,{
    if(!is.null(elisaResult$Tablestandcurve) && dim(elisaResult$Tablestandcurve)[1]!=0){
      
      output$ELISA_Table_stdcurve <- DT::renderDataTable({
        DT::datatable( 
          elisaResult$Tablestandcurve,
                       selection = 'none',
                       editable = list(target = "cell",
                                       disable = list(columns = 0:2) ),
                       #options = list(lengthChange = FALSE, autoWidth = TRUE),
                       rownames= FALSE
        )
      })
    } 
  })
  observeEvent(input$ELISA_Table_stdcurve_cell_edit, {
    cells = input$ELISA_Table_stdcurve_cell_edit
    cells$col = cells$col + 1
    elisaResult$Tablestandcurve <- editData( elisaResult$Tablestandcurve ,
                                             cells,
                                             'ELISA_Table_stdcurve')
  })
  observeEvent(input$ELISA_buttonRegression,{
    standcurve = elisaResult$Tablestandcurve
    standcurve$Concentrations = as.numeric(standcurve$Concentrations)
    if(!is.null(standcurve)){
      standcurve = standcurve %>% na.omit()
      
      
      regressionPlot = ggplot(standcurve,aes(Concentrations, Measures)) +
        geom_point() +
        theme_bw()
      
      if(input$regressionType == "Linear"){
        modelStancurve = lm(Measures~Concentrations, data = standcurve)
        
        infoLM = data.frame(x = min(standcurve$Concentrations) + c(1,1),
                            y = max(standcurve$Measures) + c(2,1.75),
                            text = c( paste0("y = ", signif(modelStancurve$coef[[2]], 5), "x + ",signif(modelStancurve$coef[[1]],5 )),
                                      paste0("Adj R2 = ",signif(summary(modelStancurve)$adj.r.squared, 5))) )
        
        fun = paste0("(x - ",modelStancurve$coef[[1]],")/", modelStancurve$coef[[2]])
        
        regressionPlot =  regressionPlot +
          geom_smooth(method='lm', col = "red") +
          geom_text(data= infoLM,
                    aes(x = x, y = y, label =text ),
                    vjust = "inward", hjust = "inward" )
        
      }
      else if(input$regressionType == "Quadratic")
        {
        #this is not implemented
        standcurve$Concentrations2 = standcurve$Concentrations^2
        modelStancurve = lm(Measures~Concentrations+Concentrations2, data = standcurve)
        
        infoLM = data.frame(x = min(standcurve$Concentrations) + c(1,1),
                            y = max(standcurve$Measures) + c(2,1.75),
                            text = c( paste0("y = ", signif(modelStancurve$coef[[3]], 5), "x^2 + ",
                                             signif(modelStancurve$coef[[2]], 5), "x + ",signif(modelStancurve$coef[[1]],5 )),
                                      paste0("Adj R2 = ",signif(summary(modelStancurve)$adj.r.squared, 5))) )
        
        fun = paste0(modelStancurve$coef[[3]],"*x^2 + ",modelStancurve$coef[[2]],"*x + ",modelStancurve$coef[[1]] )
        
        regressionPlot =  regressionPlot  +
          geom_point() +
          stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1,col="red")+
          geom_text(data= infoLM,
                    aes(x = x, y = y, label =text ),
                    vjust = "inward", hjust = "inward" )
      }
      else if(input$regressionType == "Hyperbola"){
        
        outNLreg = tryCatch(
          {
            modelStancurve<-nls(
              Measures ~ a*Concentrations/(b+Concentrations), 
              data = standcurve, #%>% group_by(Concentrations) %>% summarise(Measures = mean(Measures)),
              start = list(a = 1,b = 1)
             )
          }, 
          error = function(e){
            return(e)
          })
        
        if(!is.null(outNLreg$mess)){
          modelStancurve = NULL
          regressionPlot = ggplot()+ geom_text(data = data.frame(x = 1,y =1,text = paste0("Error: ",outNLreg$mess)),
                                               aes(x,y,label = text),color = "red")
        }else{
          modelStancurve = outNLreg
          coef = modelStancurve$m$getPars()
          r2 = 1- sum(modelStancurve$m$resid()^2)/(sum(( mean(standcurve$Measures) - modelStancurve$m$predict() )^2))
          
          infoLM = data.frame(x = min(standcurve$Concentrations) + c(1,1),
                              y = max(standcurve$Measures) + c(2,1.75),
                              text = c( paste0("y = ", signif(coef["a"], 5), "x / ( ",
                                               signif(coef["b"], 5), " + x ) "),
                                        paste0("R2 = ",signif(r2, 5))) )
          
          dfHyperbola = data.frame(x = seq(min(standcurve$Concentrations),max(standcurve$Concentrations),length.out = 20)) %>%
            mutate(y = (coef["a"]*x/((coef["b"]+x)) ) )
          
          fun = paste0(coef["b"],"*x/(",coef["a"],"-x)")
          
          regressionPlot =  regressionPlot  +
            geom_point() +
            geom_line(data = dfHyperbola,aes(x = x,y = y),size = 1,col="red" )+
            geom_text(data= infoLM,
                      aes(x = x, y = y, label =text ),
                      vjust = "inward", hjust = "inward" )
        }
      }
      
      elisaResult$Regression = list(data = modelStancurve, plot = regressionPlot, fun = function(x){ eval( parse(text = fun ) ) } )
      
    }else{
      regressionPlot = ggplot()
    }
    output$ELISAregression <- renderPlot(regressionPlot)
  })
  
  # save everytime there is a change in the results
  # ELISAresultListen <- reactive({
  #   reactiveValuesToList(elisaResult)
  # })
  # observeEvent(ELISAresultListen(), {
  #   DataAnalysisModule$elisaResult = reactiveValuesToList(elisaResult)
  # })
  
  ### End ELISA analysis ####
  
  ### CYTOTOX analysis ####
  
  # next buttons
  observeEvent(input$NextCytotoxQuantif,{
    updateTabsetPanel(session, "SideTabs",
                      selected = "tablesCYTOTOX")
  })
  #
  
  cytotoxResult = reactiveValues(
                                 Initdata= NULL,
                                 data = NULL,
                                 TablePlot = NULL,
                                 dataFinal = NULL,
                                 CYTOTOXcell_EXP = NULL,
                                 CYTOTOXcell_REP = NULL,
                                 CYTOTOXcell_SN = NULL,
                                 MapBaseline = NULL)
  
  cytotoxResult0 = list(
                        Initdata= NULL,
                        data = NULL,
                        TablePlot = NULL,
                        dataFinal = NULL,
                        CYTOTOXcell_EXP = NULL,
                        CYTOTOXcell_REP = NULL,
                        CYTOTOXcell_SN = NULL,
                        MapBaseline = NULL)
  
  
  # save everytime there is a change in the results
  CYTOTOXresultListen <- reactive({
    reactiveValuesToList(cytotoxResult)
  })
  observeEvent(CYTOTOXresultListen(), {
    DataAnalysisModule$cytotoxResult = reactiveValuesToList(cytotoxResult)
    DataAnalysisModule$cytotoxResult$Flags = reactiveValuesToList(FlagsCYTOTOX)
  })
  
  ##
  FlagsCYTOTOX <- reactiveValues(cellCoo = NULL,
                                 AllExp = "",
                                 BASEselected = "",
                                 EXPselected = "",
                                 EXPcol = NULL)
  
  observeEvent(input$LoadCYTOTOX_Button,{
    output$LoadingError_CYTOTOX <- renderText({
      validate(
        need(!is.null(input$CYTOTOXImport) && file.exists(input$CYTOTOXImport$datapath) ,
             "Please select an CYTOTOX excel file!!" )
      )
      
      mess = readfile(
        filename = input$CYTOTOXImport$datapath,
        type = "Excel",
        allDouble = T,
        colname = F,
        colors = T
      )
      
      validate(
        need(!setequal(names(mess),c("message","call")) ,
             mess[["message"]] )
      )
      
      cytotoxResult$Initdata = mess$x
      FlagsCYTOTOX$EXPcol = mess$fill
      cytotoxResult$CYTOTOXcell_SN = mess$SNtable
      
      "The CYTOTOX excel has been uploaded  with success"
    })
    
    if( !is.null(cytotoxResult$Initdata) )
    { ### alert!!! if it is already present! 
      showModal(modalDialog(
        title = "Important message",
        "Do you want to update the CYTOTOX data already present?",
        easyClose = TRUE,
        footer= tagList(actionButton("confirmUploadCYTOTOX", "Update"),
                        modalButton("Cancel")
        )
      ))
      
    }
  })
  observeEvent(input$confirmUploadCYTOTOX,{
    removeModal()
    
    for(nameList in names(cytotoxResult0)) 
      cytotoxResult[[nameList]] <- cytotoxResult0[[nameList]]
    
    output$LoadingError_CYTOTOX <- renderText({
      validate(
        need(!is.null(input$CYTOTOXImport) && file.exists(input$CYTOTOXImport$datapath) ,
             "Please select an CYTOTOX excel file!!" )
      )
      
      mess = readfile(
        filename = input$CYTOTOXImport$datapath,
        type = "Excel",
        allDouble = T,
        colname = F,
        colors = T
      )
      
      validate(
        need(!setequal(names(mess),c("message","call")) ,
             mess[["message"]])
      )
      
      cytotoxResult$Initdata = mess$x
      FlagsCYTOTOX$EXPcol = mess$fill
      cytotoxResult$CYTOTOXcell_SN = mess$SNtable
      
      "The RDs has been uploaded  with success"
    })
  })
  observe({
    if( !is.null(cytotoxResult$Initdata) && is.null(cytotoxResult$TablePlot) ){
      
      tableExcelColored(session = session,
                        Result = cytotoxResult, 
                        FlagsExp = FlagsCYTOTOX,
                        type = "Initialize")
      
      output$CYTOTOXmatrix <-renderDataTable({cytotoxResult$TablePlot})
    }
  })
  observeEvent(input$CYTOTOXmatrix_cell_clicked,{
    if(length(input$CYTOTOXmatrix_cell_clicked)!=0){
      cellSelected= as.numeric(input$CYTOTOXmatrix_cell_clicked)
      FlagsCYTOTOX$cellCoo = cellCoo = c(cellSelected[1],cellSelected[2]+1)
      print(cellCoo)
      print(cytotoxResult$CYTOTOXcell_EXP[ cellCoo[1],cellCoo[2] ])
      print(cytotoxResult$CYTOTOXcell_SN[ cellCoo[1], cellCoo[2] ])
      updateSelectizeInput(inputId = "CYTOTOXcell_EXP",
                           selected = ifelse(is.null(cytotoxResult$CYTOTOXcell_EXP[cellCoo[1],cellCoo[2]]),
                                             "",
                                             cytotoxResult$CYTOTOXcell_EXP[cellCoo[1],cellCoo[2]])
      )
      updateSelectizeInput(inputId = "CYTOTOXcell_SN",
                           selected = ifelse(is.null(cytotoxResult$CYTOTOXcell_SN[cellCoo[1],cellCoo[2]]),
                                             "",
                                             cytotoxResult$CYTOTOXcell_SN[cellCoo[1],cellCoo[2]])
      )
      updateSelectizeInput(inputId = "CYTOTOXcell_REP",
                           selected = ifelse(is.null(cytotoxResult$CYTOTOXcell_REP[cellCoo[1],cellCoo[2]]),
                                             "",
                                             cytotoxResult$CYTOTOXcell_REP[cellCoo[1],cellCoo[2]])
      )
    }
  })
  
  observeEvent(input$CYTOTOXcell_EXP,{
    if(!is.null(cytotoxResult$CYTOTOXcell_EXP)){
      cellCoo = FlagsCYTOTOX$cellCoo
      cytotoxResult$CYTOTOXcell_EXP[cellCoo[1],cellCoo[2]] = input$CYTOTOXcell_EXP
    }
  })
  observeEvent(input$CYTOTOXcell_REP,{
    if(!is.null(cytotoxResult$CYTOTOXcell_REP)){
      cellCoo = FlagsCYTOTOX$cellCoo
      cytotoxResult$CYTOTOXcell_REP[cellCoo[1],cellCoo[2]] = input$CYTOTOXcell_REP
    }
  })
  observeEvent(input$CYTOTOXcell_SN,{
    if(!is.null(cytotoxResult$CYTOTOXcell_SN)){
      CYTOTOXtb = cytotoxResult$TablePlot
      cellCoo = FlagsCYTOTOX$cellCoo
      
      if(!is.null(cellCoo)){
        value.bef = cytotoxResult$CYTOTOXcell_SN[cellCoo[1],cellCoo[2]] 
        value.now = input$CYTOTOXcell_SN
        
        # if the value does not change or it is still "Color " then the matrix is not update
        if( value.now != ""  && value.now!=value.bef){
          cytotoxResult$CYTOTOXcell_SN[cellCoo[1],cellCoo[2]] = value.now
          CYTOTOXtb$x$data[cellCoo[1],paste0("Col",cellCoo[2])] = value.now
          
          if(! input$CYTOTOXcell_SN %in% FlagsCYTOTOX$AllExp){
            FlagsCYTOTOX$AllExp = unique(c(FlagsCYTOTOX$AllExp,input$CYTOTOXcell_SN))
            print(FlagsCYTOTOX$AllExp)
          }
          
          ## updating table and colors definition depending on the cell fill 
          tableExcelColored(session = session,
                            Result = cytotoxResult, 
                            FlagsExp = FlagsCYTOTOX,
                            type = "Update")
          #####
          output$CYTOTOXmatrix <-renderDataTable({cytotoxResult$TablePlot})
        }
      }
    }
  })
  
  ## update Baselines checkBox
  observeEvent(FlagsCYTOTOX$AllExp,{
    if(length(FlagsCYTOTOX$AllExp) > 1){
      exp = FlagsCYTOTOX$AllExp
      exp = exp[exp != ""]
      
      exp_selec = input$CYTOTOX_baselines
      
      updateSelectizeInput(session,"CYTOTOX_baselines",
                               choices = exp,
                               selected = FlagsCYTOTOX$BASEselected )
    }
  })
  
  ## select the baselines
  observeEvent(input$CYTOTOX_baselines,{
    FlagsCYTOTOX$BASEselected = input$CYTOTOX_baselines
    FlagsCYTOTOX$EXPselected = FlagsCYTOTOX$AllExp[! FlagsCYTOTOX$AllExp %in% FlagsCYTOTOX$BASEselected]
  },ignoreNULL = F)

  toListen_cytotox <- reactive({
    return( list(cytotoxResult$CYTOTOXcell_EXP,cytotoxResult$CYTOTOXcell_SN,FlagsCYTOTOX$BASEselected) )
  })
  observeEvent(toListen_cytotox(),{
    baselines = FlagsCYTOTOX$BASEselected
    baselines = baselines[baselines != ""]
    if(length(baselines) > 0 )
    {
      CYTOTOXcell_value = data.frame(
        row = c(t(row(cytotoxResult$Initdata))),
        col = c(t(col(cytotoxResult$Initdata))),
        Val = c(t(cytotoxResult$Initdata))
      ) 
      CYTOTOXcell_SN = data.frame(
        row = c(t(row(cytotoxResult$CYTOTOXcell_SN))),
        col = c(t(col(cytotoxResult$CYTOTOXcell_SN))),
        SN = c(t(cytotoxResult$CYTOTOXcell_SN))
      ) 
      CYTOTOXcell_EXP = data.frame(
        row = c(t(row(cytotoxResult$CYTOTOXcell_EXP))),
        col = c(t(col(cytotoxResult$CYTOTOXcell_EXP))),
        EXP = c(t(cytotoxResult$CYTOTOXcell_EXP))
      ) 
      CYTOTOXcell_REP = data.frame(
        row = c(t(row(cytotoxResult$CYTOTOXcell_REP))),
        col = c(t(col(cytotoxResult$CYTOTOXcell_REP))),
        REP = c(t(cytotoxResult$CYTOTOXcell_REP))
      ) 
     
      CYTOTOXcell = merge(merge(merge(CYTOTOXcell_REP,CYTOTOXcell_EXP) , CYTOTOXcell_SN), CYTOTOXcell_value) %>%
        group_by(SN,EXP,REP) %>%
        summarise(MeanV = mean(Val,na.rm = T)) %>%
        ungroup()
      
      CYTOTOXcell_base = CYTOTOXcell %>%
        filter(SN == baselines) %>%
        rename(MeanBaseV = MeanV, Baseline = SN) 
      # if no exp conditions is used for the baseline then we repeat  exp given for the other SN
      # in thius way the same baseline is used for each SN
      if(all(CYTOTOXcell_base$EXP == "") ) {
        CYTOTOXcell_base = do.call("rbind", lapply(unique(CYTOTOXcell$EXP), function(x) CYTOTOXcell_base %>% mutate(EXP = x) ) )
      }
      
      CYTOTOXcell = CYTOTOXcell %>%  filter(SN != baselines)
      CYTOTOXcell = merge(CYTOTOXcell_base,CYTOTOXcell,by= c("REP","EXP"),all.y = T)
      CYTOTOXcell = CYTOTOXcell %>% mutate(Res = (MeanV-MeanBaseV)/(100-MeanBaseV)*100)
      
      cytotoxResult$data =  CYTOTOXcell
      cytotoxResult$dataFinal =  CYTOTOXcell %>%
        select(-Baseline, - MeanBaseV, - MeanV ) %>%
        tidyr::spread(key= "REP", value = "Res") %>%
        rename(`Sample Name` = SN,
               `Experimental Condition` = EXP)
      
      output$CYTOTOXtables = renderDT({
        datatable(
          cytotoxResult$dataFinal,
        rownames= FALSE,
        options = list(
          scrollX = TRUE,
          lengthChange = FALSE,
          dom = 't')
        )
      })
      
      output$CYTOTOXplots = renderPlot({
        pl1 = CYTOTOXcell %>%
          group_by(EXP,SN) %>%
          summarize(Mean = mean(MeanV),SD = sd(MeanV)) %>%
          ggplot(aes(x = as.factor(EXP),y = Mean ,fill = SN, col = SN)) + 
          geom_bar(stat="identity", color="black", position=position_dodge()) +
          geom_errorbar(aes(ymin=Mean-SD, ymax=Mean+SD), width=.2,
                        position=position_dodge(.9)) +
          theme_bw()+ 
          theme(legend.position = "bottom")+
          labs(title = "Sample Name mean values with standard deviation bars",
               col="Sample Name",fill="Sample Name",
               x = "Experimental condition", y= "Mean Values")
        
        pl2 = CYTOTOXcell %>% ggplot() +
          geom_boxplot(aes(x = as.factor(EXP),y = Res,fill = SN, col = SN),alpha = 0.4) +
          theme_bw() + theme(legend.position = "bottom") +
          labs(x = "Experimental condition", y= "% Values w.r.t \nthe baseline cell death",
               col="Sample Name",fill="Sample Name")
        pl1+pl2
      })
      
      }
  })
  
  ### End CYTOTOX analysis ####
  
  ### Start Statistic ####
  DataStatisticModule = reactiveValues(WB = list(),
                                       PRCC = list(),
                                       ELISA = list(),
                                       ENDOC = list(),
                                       CYTOTOX = list(),
                                       Flag = F)
  
  DataStatisticresultListen <- reactive({
    reactiveValuesToList(DataStatisticModule)
  })
  
  observeEvent(DataStatisticresultListen(),{
    
    if(DataStatisticModule$Flag){
      AnalysisNames = names(DataStatisticModule)[names(DataStatisticModule) != "Flag"]
      Analysis = rep(F,length(AnalysisNames) )
      names(Analysis) = AnalysisNames
      for(j in AnalysisNames)
        Analysis[j] = all(sapply(DataStatisticModule[[j]], is.null))
      
      AnalysisNames = AnalysisNames[!Analysis]
      
      updateSelectizeInput(inputId = "StatAnalysis",
                           choices = c("",AnalysisNames),
                           selected = "")
      
      DataStatisticModule$Flag = F
    }
    
  })
  
  observeEvent(input$StatAnalysis,{
    
    if(input$StatAnalysis != ""){
      DataStatisticModule[[input$StatAnalysis]] -> results
      do.call(rbind,results) -> results
      
      res = resTTest = NULL
      resplot = ggplot()
      
      if(input$StatAnalysis == "WB"){
        resTTest = res = results %>%
          select(DataSet,SampleName,AdjRelDens) %>%
          mutate(SampleName = gsub(pattern = "^[0-9]. ",x = SampleName,replacement = "")) %>%
          tidyr::spread(key = DataSet,value = AdjRelDens ) 
        
        res$Mean = apply(res[,paste(unique(results$DataSet))],1,mean)
        res$Sd = apply(res[,paste(unique(results$DataSet))],1,sd)

        resplot =ggplot(res, aes(x = SampleName,
                                 y = Mean)) + 
          geom_bar(stat="identity", color="black", fill = "#BAE1FF",
                          position=position_dodge()) +
          geom_errorbar(aes(ymin=Mean-Sd, ymax=Mean+Sd), width=.2,
                        position=position_dodge(.9)) +
          theme_bw()
        
        combo = expand.grid(resTTest$SampleName,resTTest$SampleName)
        combo = combo[combo$Var1 != combo$Var2, ]
        resTTest = do.call(rbind,
                           lapply(1:dim(combo)[1],function(x){
          sn = combo[x,]
          ttest = t.test(resTTest[resTTest$SampleName == sn$Var1, -1],resTTest[resTTest$SampleName == sn$Var2, -1]) 
          data.frame(Ttest = paste(sn$Var1, " vs ",sn$Var2), 
                     pValue = ttest$p.value,
                     conf.int = paste(ttest$conf.int,collapse = ";")
                    )
          })
        )
        
        }
      
      output$TabStat = renderDT({res})
      output$PlotStat = renderPlot({resplot})
      output$TabTTest = renderDT({resTTest})
    }
  })
  
  ### End Statistic ####
  
  ### DATAVERSE ####
  
  observeEvent(input$APIkey,{
    pathORCA <- system.file("Data", package = "ORCA")
    
    if(input$APIkey != "") # the last key used is saved
      write(input$APIkey,file = paste0(pathORCA,"/.APIkey"))

  })
  
  DataAnalysisModule0 <- list(wbResult = wbResult0,
                              wbquantResult = wbquantResult0,
                              endocResult = endocResult0,
                              elisaResult = elisaResult0,
                              pcrResult = pcrResult0,
                              cytotoxResult = cytotoxResult0)
  
  observe({
    listDataAnalysisModule = reactiveValuesToList(DataAnalysisModule)
    namesAnalysis = sapply(names(listDataAnalysisModule), function(x){
      if(x == "wbquantResult"){
        if(! identical(DataAnalysisModule[[x]]$NormWBanalysis,DataAnalysisModule0[[x]]$NormWBanalysis) )
           return(x)
        else
          return("")
      }
      else if(!is.null(DataAnalysisModule[[x]]$Initdata) || !identical(DataAnalysisModule[[x]]$Initdata,DataAnalysisModule0[[x]]$Initdata) )
        return(x)
      else
        return("")
      })
    namesAnalysis = namesAnalysis[namesAnalysis!= ""]
    if(length(namesAnalysis)>0)
      updateSelectizeInput(inputId = "selectAnalysis_DV",
                          choices = MapAnalysisNames[namesAnalysis])
  })
  
  observeEvent(input$DataverseUpload_Button,{

    if(input$selectAnalysis_DV != ""){
  
      if(input$Title_DV == "" && input$Author_DV == "" && input$Description_DV == "" &&
         input$AuthorAff_DV== "" && input$ContactN_DV == "" && input$ContactEmail_DV == "")
          output$LoadingError_DATAVERSE = renderText("Error: missing information")
      else{
        # creation of a temporary folder
        tempfolder = paste0(tempdir(check = T),"/ORCA")
        system(paste0("mkdir ",tempfolder))
        system(paste0("mkdir ",tempfolder,"/dataset"))
        # create the metadata
        result <- rjson::fromJSON(file = system.file("docker","metadata.json", package = "ORCA") )
        result$dataset_title = input$Title_DV
        result$dataset_description = paste0(input$Description_DV,"\n This dataset has been obtained using the ORCA application, specifically the module: ", input$selectAnalysis_DV)
        result$author_name = input$Author_DV
        result$author_affiliation= input$AuthorAff_DV
        result$dataset_contact_name = input$ContactN_DV
        result$dataset_contact_email = input$ContactEmail_DV
        # result$subject = as.vector(result$subject)
        write(rjson::toJSON(result), file=paste0(tempfolder,"/metadata.json") )
  
        # move the file in the temporary folder
  
        saveExcel(filename = paste0(tempfolder,"/dataset/",
                                    gsub(pattern = " ", 
                                         x = input$selectAnalysis_DV,
                                         replacement = ""),".xlsx"),
                  ResultList = DataAnalysisModule[[ names(MapAnalysisNames[MapAnalysisNames == input$selectAnalysis_DV])]] ,
                  analysis = input$selectAnalysis_DV )
        
        saveRDS(DataAnalysisModule[[ names(MapAnalysisNames[MapAnalysisNames == input$selectAnalysis_DV])]] ,
                file = paste0(tempfolder,"/dataset/ORCA_",
                                         gsub(pattern = " ", 
                                              x = input$selectAnalysis_DV,
                                              replacement = ""),".RDs"))
        # docker run
        ORCA::docker.run(params = paste0("--volume ", tempfolder,
                   ":/Results/ -d qbioturin/orca-upload-dataverse python3 main.py /Results/metadata.json /Results/dataset") 
        )
  
      }
    
    }
  })
  
  #initiate_sword_dataset()
  #add_dataset_file()
  #publish_dataset()
  
  #### End DATAVERSE
  
  ### Loading files ####
  UploadDataAnalysisModuleAllFalse  = reactiveValues(FlagALL = F,
                                                     FlagUpdate = F,
                                                     FlagWB = F,
                                                     FlagPRCC = F,
                                                     FlagELISA = F,
                                                     FlagCYTOTOX = F,
                                                     FlagENDOC = F)
  UploadDataAnalysisModule = reactiveValues(FlagALL = F,
                                            FlagUpdate = F,
                                            FlagWB = F,
                                            FlagPRCC = F,
                                            FlagELISA = F,
                                            FlagCYTOTOX = F,
                                            FlagENDOC = F)
  
  
  # upload in the statistic module
  observeEvent(input$loadStatAnalysis_file_Button,{
    output$loadStatAnalysis_Error <- renderText({
      validate(
        need(!is.null(input$loadStatAnalysis_file) && all(file.exists(input$loadStatAnalysis_file$datapath)) ,
             "Please select one RDs file generated throught the Data Analysis module." )
      )
      
      datapaths = input$loadStatAnalysis_file$datapath
      for(dpath in 1:length(datapaths)){
        mess = readRDS(datapaths[dpath])
        
        validate(
          need(all(names(mess) %in% names(DataAnalysisModule)) ||
                 all(names(mess) %in% names(elisaResult)) ||
                 all(names(mess) %in% names(wbquantResult)) || 
                 all(names(mess) %in% names(pcrResult)) ||
                 all(names(mess) %in% names(cytotoxResult)) ||
                 all(names(mess) %in% names(endocResult)) ,
               paste(mess[["message"]],"\n The file must be RDs saved throught the Data Analysis module." ))
        )
        
        DataStatisticModule$Flag = T
        
        if( all(names(mess) %in% names(wbquantResult)) || all(names(mess) %in% names(DataAnalysisModule)) ){
          DataStatisticModule$WB[[dpath]] <- mess$AdjRelDensitiy %>% mutate(DataSet = dpath)
        }else if( all(names(mess) %in% names(pcrResult)) || all(names(mess) %in% names(DataAnalysisModule))){
          DataAnalysisModule$PRCC[[dpath]]  <- mess
        }else if(all(names(mess) %in% names(endocResult)) || all(names(mess) %in% names(DataAnalysisModule))){
          DataAnalysisModule$ENDOC[[dpath]]  <- mess
        }else if(all(names(mess) %in% names(elisaResult)) || all(names(mess) %in% names(DataAnalysisModule))){
          DataAnalysisModule$ELISA[[dpath]]  <- mess
        }else if(all(names(mess) %in% names(cytotoxResult)) || all(names(mess) %in% names(DataAnalysisModule))){
          DataAnalysisModule$CYTOTOX[[dpath]]  <- mess
        }
        
      }
      
      "The RDs files have been uploaded  with success."
      
    })
  })
  
  # general upload in the app
  observeEvent(input$loadAnalysis_Button,{
    output$loadAnalysis_Error <- renderText({
      validate(
        need(!is.null(input$loadAnalysis_file) && all(file.exists(input$loadAnalysis_file$datapath)) ,
             "Please select one RDs file generated throught the Data Analysis module." )
      )
      
      mess = readRDS(input$loadAnalysis_file$datapath)
      
      messNames = names(mess)
      if("Flags"%in% messNames) messNames = messNames[ messNames != "Flags"]
      
      validate(
        need(all(messNames %in% names(DataAnalysisModule)) ||
               all(messNames %in% names(elisaResult)) ||
               all(messNames %in% names(wbResult)) || 
               all(messNames %in% names(pcrResult)) ||
               all(messNames %in% names(cytotoxResult)) ||
               all(messNames %in% names(endocResult)) ,
             paste(mess[["message"]],"\n The file must be RDs saved throught the Data Analysis module." ))
      )
      
      if(all(messNames %in% names(DataAnalysisModule)) ){
        DataAnalysisModule <- mess
        UploadDataAnalysisModule$FlagALL = T
      }else if( all(messNames %in% names(wbResult)) ){
        DataAnalysisModule$wbResult <- mess
        UploadDataAnalysisModule$FlagWB = T
      }else if( all(messNames %in% names(pcrResult)) ){
        DataAnalysisModule$pcrResult <- mess
        UploadDataAnalysisModule$FlagPRCC = T
      }else if(all(messNames %in% names(endocResult)) ){
        DataAnalysisModule$endocResult <- mess
        UploadDataAnalysisModule$FlagENDOC = T
      }else if(all(messNames %in% names(elisaResult)) ){
        DataAnalysisModule$elisaResult <- mess
        UploadDataAnalysisModule$FlagELISA = T
      }else if(all(messNames %in% names(cytotoxResult)) ){
        DataAnalysisModule$cytotoxResult <- mess
        UploadDataAnalysisModule$FlagCYTOTOX = T
      }
      
      UploadDataAnalysisModule$FlagUpdate = T
      
      "The RDs file has been uploaded  with success."
      
    })
  })
  
  observeEvent(UploadDataAnalysisModule$FlagUpdate,{
    if(UploadDataAnalysisModule$FlagUpdate){
      
      if(UploadDataAnalysisModule$FlagWB || UploadDataAnalysisModule$FlagALL){
        UploadRDs(Flag = "WB",
                  session = session,
                  output = output,
                  DataAnalysisModule = DataAnalysisModule,
                  Result = wbResult, 
                  FlagsExp = Flags,
                  PanelStructures = PanelStructures)
      }
      else if(UploadDataAnalysisModule$FlagPRCC || UploadDataAnalysisModule$FlagALL){
        UploadRDs(Flag = "PRCC",
                  session = session,
                  output = output,
                  DataAnalysisModule = DataAnalysisModule,
                  Result = prccResult, 
                  FlagsExp = FlagsPRCC)
      }
      else if(UploadDataAnalysisModule$FlagENDOC || UploadDataAnalysisModule$FlagALL){
        UploadRDs(Flag = "ENDOC",
                  session = session,
                  output = output,
                  DataAnalysisModule = DataAnalysisModule,
                  Result = endocResult, 
                  FlagsExp = FlagsENDOC)
      }
      else if(UploadDataAnalysisModule$FlagELISA || UploadDataAnalysisModule$FlagALL){
        UploadRDs(Flag = "ELISA",
                  session = session,
                  output = output,
                  DataAnalysisModule = DataAnalysisModule,
                  Result = elisaResult, 
                  FlagsExp = FlagsELISA)
        
      }
      else if(UploadDataAnalysisModule$FlagCYTOTOX || UploadDataAnalysisModule$FlagALL){
        
        UploadRDs(Flag = "CYTOTX",
                  session = session,
                  output = output,
                  DataAnalysisModule = DataAnalysisModule,
                  Result = cytotoxResult, 
                  FlagsExp = FlagsCYTOTOX)
        
      }

            UploadDataAnalysisModule = UploadDataAnalysisModuleAllFalse
    }
    
  })
  ### Download files ####
  
  output$downloadButtonExcel_ELISA <- downloadHandler(
    filename = function() {
      paste('ELISAanalysis-', Sys.Date(), '.xlsx', sep='')
    },
    content = function(file) {
      saveExcel(filename = file, ResultList=DataAnalysisModule$elisaResult , analysis = "ELISA")
    }
  )
  
  output$downloadButtonExcel_PCR <- downloadHandler(
    filename = function() {
      paste('RTqPCRanalysis-', Sys.Date(), '.xlsx', sep='')
    },
    content = function(file) {
      saveExcel(filename = file, ResultList=DataAnalysisModule$pcrResult , analysis = "RT-qPCR")
    }
  )
  
  output$downloadButtonExcel_WB <- downloadHandler(
    filename = function() {
      paste('WBanalysis-', Sys.Date(), '.xlsx', sep='')
    },
    content = function(file) {
      saveExcel(filename = file, ResultList=DataAnalysisModule$wbResult , analysis = "WB")
    }
  )
  
  output$downloadButtonExcel_WBquant <- downloadHandler(
    filename = function() {
      paste('WBquant_analysis-', Sys.Date(), '.xlsx', sep='')
    },
    content = function(file) {
      saveExcel(filename = file, ResultList=DataAnalysisModule$wbquantResult , analysis = "WB comparison")
    }
  )
  output$downloadButtonExcel_CYTOTOX <- downloadHandler(
    filename = function() {
      paste('CYTOTOXanalysis-', Sys.Date(), '.xlsx', sep='')
    },
    content = function(file) {
      saveExcel(filename = file, ResultList=DataAnalysisModule$cytotoxResult , analysis = "Cytotoxicity")
    }
  )
  
  output$downloadButtonExcel_ENDOC <- downloadHandler(
    filename = function() {
      paste('ENDOCanalysis-', Sys.Date(), '.xlsx', sep='')
    },
    content = function(file) {
      saveExcel(filename = file, ResultList=DataAnalysisModule$endocResult , analysis = "Endocytosis")
    }
  )
  
  output$downloadRDSwholeAnalysis <- downloadHandler(
    filename = function() {
      paste('DataIntegrationModuleAnalysis-', Sys.Date(), '.RDs', sep='')
    },
    content = function(file) {
      saveRDS(reactiveValuesToList(DataAnalysisModule), file = file)
    }
  )
  
  output$downloadReport <- downloadHandler(
    filename = function() {
      "Report.html"
    },
    content = function(file) {
      parmsList = list(ResultList = reactiveValuesToList(DataAnalysisModule))
      rmarkdown::render(system.file("Shiny","report.Rmd", package = "ORCA"),
                        output_file = file,output_format = "html_document",
                        params = parmsList )
    }
  )
  
  output$downloadButton_WB <- downloadHandler(
    filename = function() {
      paste('WBanalysis-', Sys.Date(), '.RDs', sep='')
    },
    content = function(file) {
      results = DataAnalysisModule$wbResult
      saveRDS(results, file = file)
    }
  )
  
  output$downloadButton_WBquant <- downloadHandler(
    filename = function() {
      paste('WBanalysisQuantification-', Sys.Date(), '.RDs', sep='')
    },
    content = function(file) {
      results = DataAnalysisModule$wbquantResult
      saveRDS(results, file = file)
    }
  )
  
  output$downloadButton_PCR <- downloadHandler(
    filename = function() {
      paste('PCRanalysis-', Sys.Date(), '.RDs', sep='')
    },
    content = function(file) {
      results = DataAnalysisModule$pcrResult
      saveRDS(results, file = file)
    }
  )
  
  output$downloadButton_ENDOC <- downloadHandler(
    filename = function() {
      paste('ENDOCanalysis-', Sys.Date(), '.RDs', sep='')
    },
    content = function(file) {
      results = DataAnalysisModule$endocResult
      saveRDS(results, file = file)
    }
  )
  
  
  output$downloadButton_CYTOTOX <- downloadHandler(
    filename = function() {
      paste('CYTOTOXanalysis-', Sys.Date(), '.RDs', sep='')
    },
    content = function(file) {
      results = DataAnalysisModule$cytotoxResult
      saveRDS(results, file = file)
    }
  )
  
  output$downloadButton_ELISA <- downloadHandler(
    filename = function() {
      paste('ELISAanalysis-', Sys.Date(), '.RDs', sep='')
    },
    content = function(file) {
      results = DataAnalysisModule$elisaResult
      saveRDS(results, file = file)
    }
  )
  #### end save files ###
  
  observe({namesAll <<- unique( c("Flags",names(wbResult), names(wbquantResult), names(pcrResult), names(endocResult)) )})
  
  return()
  
}
